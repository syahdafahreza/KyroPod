<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>KyroPod | By Syahda Fahreza</title>
    <link rel="stylesheet" href="themes/neuromorphic.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css" />
    <link href="fontawesome/css/fontawesome.css" rel="stylesheet" />
    <link href="fontawesome/css/brands.css" rel="stylesheet" />
    <link href="fontawesome/css/solid.css" rel="stylesheet" />
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700&display=swap" rel="stylesheet" />
    <link rel="icon" type="image/svg+xml" href="svg/compact-disc-solid-light.svg"
        media="(prefers-color-scheme: dark)" />
    <link rel="icon" type="image/svg+xml" href="svg/compact-disc-solid-dark.svg"
        media="(prefers-color-scheme: light)" />
    <link rel="icon" type="image/svg+xml" href="svg/compact-disc-solid-light.svg" />
    <link rel="manifest" href="manifest.json" />
    <script src="https://kit.fontawesome.com/b2e4954604.js" crossorigin="anonymous"></script>
    <script>
        if ("serviceWorker" in navigator) {
            window.addEventListener("load", () => {
                navigator.serviceWorker
                    .register("sw.js") // Path to your service worker file
                    .then((registration) => {
                        console.log(
                            "ServiceWorker registration successful with scope: ",
                            registration.scope
                        );
                    })
                    .catch((error) => {
                        console.log("ServiceWorker registration failed: ", error);
                    });
            });
        }
    </script>
</head>

<body>
    <div id="root"></div>

    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jsmediatags@3.9.7/dist/jsmediatags.min.js"></script>

    <script type="text/babel">
        const { useState, useRef, useEffect, useCallback } = React;

        function arrayBufferToBase64(buffer) {
            let binary = '';
            const bytes = new Uint8Array(buffer);
            const len = bytes.byteLength;
            for (let i = 0; i < len; i++) {
                binary += String.fromCharCode(bytes[i]);
            }
            return window.btoa(binary);
        }

        // --- CUSTOM HOOK: useMarquee ---
        const useMarquee = (text, targetRef, gapPixels = 30, speed = 30) => {
            const [isOverflowing, setIsOverflowing] = useState(false);

            useEffect(() => {
                const checkOverflowAndSetMarquee = () => {
                    if (targetRef.current) {
                        const tempSpan = document.createElement("span");
                        tempSpan.style.visibility = "hidden";
                        tempSpan.style.position = "absolute";
                        tempSpan.style.whiteSpace = "nowrap";

                        const computedStyle = getComputedStyle(targetRef.current);
                        tempSpan.style.fontSize = computedStyle.fontSize;
                        tempSpan.style.fontFamily = computedStyle.fontFamily;
                        tempSpan.style.fontWeight = computedStyle.fontWeight;
                        tempSpan.style.letterSpacing = computedStyle.letterSpacing;
                        tempSpan.textContent = text;

                        document.body.appendChild(tempSpan);
                        const singleTextWidth = tempSpan.scrollWidth;
                        document.body.removeChild(tempSpan);

                        const containerWidth = targetRef.current.clientWidth;
                        const overflows = singleTextWidth > containerWidth;

                        setIsOverflowing(overflows);

                        if (overflows) {
                            const distanceToScroll = singleTextWidth + gapPixels;
                            const duration = distanceToScroll / speed;
                            targetRef.current.style.setProperty(
                                "--marquee-duration",
                                `${duration}s`
                            );
                            targetRef.current.style.setProperty(
                                "--marquee-distance",
                                `-${distanceToScroll}px`
                            );
                        } else {
                            targetRef.current.style.setProperty("--marquee-duration", "0s");
                            targetRef.current.style.setProperty(
                                "--marquee-distance",
                                "0px"
                            );
                        }
                    }
                };
                const timeoutId = setTimeout(checkOverflowAndSetMarquee, 100);
                window.addEventListener("resize", checkOverflowAndSetMarquee);
                return () => {
                    clearTimeout(timeoutId);
                    window.removeEventListener("resize", checkOverflowAndSetMarquee);
                };
            }, [text, targetRef, gapPixels, speed]);
            return { isOverflowing };
        };

        const useAudioStateSync = (audioRef, setIsPlaying) => {
            useEffect(() => {
                const audio = audioRef.current;
                if (!audio) return;

                const handlePlay = () => setIsPlaying(true);
                const handlePause = () => setIsPlaying(false);
                // handleEnded di useAudioStateSync tidak lagi mengatur setIsPlaying(false) secara langsung
                // karena handleAudioEnded di App component akan memanggil playNextSong yang akan mengatur isPlaying.
                // Ini mencegah isPlaying menjadi false sesaat sebelum lagu berikutnya mulai.
                // const handleEnded = () => setIsPlaying(false); 

                audio.addEventListener('play', handlePlay);
                audio.addEventListener('pause', handlePause);
                // audio.addEventListener('ended', handleEnded); // Dihapus dari sini

                return () => {
                    audio.removeEventListener('play', handlePlay);
                    audio.removeEventListener('pause', handlePause);
                    // audio.removeEventListener('ended', handleEnded); // Dihapus dari sini
                };
            }, [audioRef, setIsPlaying]);
        };
        // --- END CUSTOM HOOK ---

        function App() {
            const audioRef = useRef(null);
            const fileInputRef = useRef(null);
            const currentObjectUrl = useRef(null);
            const sortButtonRef = useRef(null);
            const dropupMenuRef = useRef(null);
            const audioContextRef = useRef(null);
            const sourceNodeRef = useRef(null);
            const gainNodeRef = useRef(null);
            const lowShelfFilterRef = useRef(null);
            const peakingFilterRef = useRef(null);
            const highShelfFilterRef = useRef(null);

            const [playlist, setPlaylist] = useState([]);
            const [currentSongIndex, setCurrentSongIndex] = useState(null);
            const [isPlaying, setIsPlaying] = useState(false);
            useAudioStateSync(audioRef, setIsPlaying);

            // --- FIX: Ref untuk isPlaying ---
            const isPlayingRef = useRef(isPlaying);
            useEffect(() => {
                isPlayingRef.current = isPlaying;
            }, [isPlaying]);
            // --- END FIX ---

            const [isRepeating, setIsRepeating] = useState(false);
            const [isShuffling, setIsShuffling] = useState(false);
            const [isBuffering, setIsBuffering] = useState(false);
            const [albumArtUrl, setAlbumArtUrl] = useState("https://placehold.co/200x200/bec8e4/9baacf?text=No+Art");
            const [songTitle, setSongTitle] = useState("Tidak ada lagu yang sedang diputar");
            const [songArtist, setSongArtist] = useState("");
            const [currentTime, setCurrentTime] = useState(0);
            const [duration, setDuration] = useState(0);
            const [volume, setVolume] = useState(0.8);
            const [isSidebarOpen, setIsSidebarOpen] = useState(false);
            const [isEQSidebarOpen, setIsEQSidebarOpen] = useState(false);
            const [isSortDropupOpen, setIsSortDropupOpen] = useState(false);
            const [isSearchActive, setIsSearchActive] = useState(false);
            const [searchQuery, setSearchQuery] = useState("");
            const titleRef = useRef(null);
            const artistRef = useRef(null);
            const [eqSettings, setEqSettings] = useState({ low: 0, mid: 0, high: 0 });
            const gapPixels = 30;
            const { isOverflowing: isTitleOverflowing } = useMarquee(songTitle, titleRef, gapPixels);
            const { isOverflowing: isArtistOverflowing } = useMarquee(songArtist, artistRef, gapPixels);
            const filteredPlaylist = playlist.filter((song) => song.name.toLowerCase().includes(searchQuery.toLowerCase()));

            useEffect(() => {
                const audio = audioRef.current;
                if (!audio) return;
                const handleWaiting = () => setIsBuffering(true);
                const handlePlaying = () => setIsBuffering(false);
                audio.addEventListener('waiting', handleWaiting);
                audio.addEventListener('playing', handlePlaying);
                return () => {
                    audio.removeEventListener('waiting', handleWaiting);
                    audio.removeEventListener('playing', handlePlaying);
                };
            }, []);

            const toggleEQSidebar = () => {
                setIsEQSidebarOpen((prevState) => !prevState);
                setIsSidebarOpen(false);
                if (!isEQSidebarOpen && audioContextRef.current && audioContextRef.current.state === "suspended") {
                    audioContextRef.current.resume().catch((e) => console.error("Error resuming AudioContext:", e));
                }
            };

            const handleEQChange = useCallback((band, value) => {
                setEqSettings((prevSettings) => ({ ...prevSettings, [band]: parseFloat(value) }));
            }, []);

            useEffect(() => {
                const audio = audioRef.current;
                if (!audio) return;
                if (!audioContextRef.current) {
                    audioContextRef.current = new (window.AudioContext || window.webkitAudioContext)();
                }
                const audioContext = audioContextRef.current;
                if (!sourceNodeRef.current || sourceNodeRef.current.mediaElement !== audio) {
                    if (sourceNodeRef.current) sourceNodeRef.current.disconnect();
                    try {
                        sourceNodeRef.current = audioContext.createMediaElementSource(audio);
                    } catch (e) {
                        console.error("Error creating MediaElementSource:", e); return;
                    }
                }
                if (!gainNodeRef.current) {
                    gainNodeRef.current = audioContext.createGain();
                    gainNodeRef.current.gain.value = volume;
                }
                if (!lowShelfFilterRef.current) {
                    lowShelfFilterRef.current = audioContext.createBiquadFilter();
                    lowShelfFilterRef.current.type = "lowshelf";
                    lowShelfFilterRef.current.frequency.value = 250;
                }
                if (!peakingFilterRef.current) {
                    peakingFilterRef.current = audioContext.createBiquadFilter();
                    peakingFilterRef.current.type = "peaking";
                    peakingFilterRef.current.frequency.value = 1500;
                    peakingFilterRef.current.Q.value = 1;
                }
                if (!highShelfFilterRef.current) {
                    highShelfFilterRef.current = audioContext.createBiquadFilter();
                    highShelfFilterRef.current.type = "highshelf";
                    highShelfFilterRef.current.frequency.value = 4000;
                }
                sourceNodeRef.current.disconnect();
                gainNodeRef.current.disconnect();
                lowShelfFilterRef.current.disconnect();
                peakingFilterRef.current.disconnect();
                try {
                    sourceNodeRef.current.connect(gainNodeRef.current);
                    gainNodeRef.current.connect(lowShelfFilterRef.current);
                    lowShelfFilterRef.current.connect(peakingFilterRef.current);
                    peakingFilterRef.current.connect(highShelfFilterRef.current);
                    highShelfFilterRef.current.connect(audioContext.destination);
                } catch (e) { console.error("Error connecting audio nodes:", e); }
            }, []); // Should ideally re-run if audio element changes, but audioRef.current is stable.

            useEffect(() => {
                if (!lowShelfFilterRef.current || !peakingFilterRef.current || !highShelfFilterRef.current) return;
                lowShelfFilterRef.current.gain.value = eqSettings.low;
                peakingFilterRef.current.gain.value = eqSettings.mid;
                highShelfFilterRef.current.gain.value = eqSettings.high;
            }, [eqSettings]);

            useEffect(() => {
                if (gainNodeRef.current) gainNodeRef.current.gain.value = volume;
            }, [volume]);

            const handleSearchClick = () => { setIsSearchActive((prev) => !prev); if (isSearchActive) setSearchQuery(""); };
            const toggleSortDropup = () => setIsSortDropupOpen((prev) => !prev);

            const sortPlayListBy = (criteria) => {
                setPlaylist((prevPlaylist) => {
                    const newPlaylist = [...prevPlaylist];
                    newPlaylist.sort((a, b) => {
                        let valA, valB;
                        if (criteria === "title") { valA = (a.name || "").toLowerCase(); valB = (b.name || "").toLowerCase(); }
                        else if (criteria === "artist") { valA = (a.metadata?.artist || a.name || "").toLowerCase(); valB = (b.metadata?.artist || b.name || "").toLowerCase(); }
                        else if (criteria === "dateAdded") { valA = a.lastModified; valB = b.lastModified; }
                        if (valA < valB) return -1; if (valA > valB) return 1; return 0;
                    });
                    return newPlaylist;
                });
                setIsSortDropupOpen(false);
            };

            useEffect(() => {
                const handleClickOutside = (event) => {
                    if (isSortDropupOpen && dropupMenuRef.current && !dropupMenuRef.current.contains(event.target) && sortButtonRef.current && !sortButtonRef.current.contains(event.target)) {
                        setIsSortDropupOpen(false);
                    }
                };
                const positionDropupMenu = () => {
                    if (isSortDropupOpen && sortButtonRef.current && dropupMenuRef.current) {
                        const buttonRect = sortButtonRef.current.getBoundingClientRect();
                        const menuElement = dropupMenuRef.current;
                        menuElement.style.top = `${buttonRect.top - menuElement.offsetHeight - 10}px`;
                        menuElement.style.left = `${buttonRect.left}px`;
                        menuElement.style.minWidth = `${buttonRect.width}px`;
                    }
                };
                if (isSortDropupOpen) {
                    document.addEventListener("mousedown", handleClickOutside);
                    window.addEventListener("resize", positionDropupMenu);
                    window.addEventListener("scroll", positionDropupMenu);
                    setTimeout(positionDropupMenu, 0);
                }
                return () => {
                    document.removeEventListener("mousedown", handleClickOutside);
                    window.removeEventListener("resize", positionDropupMenu);
                    window.removeEventListener("scroll", positionDropupMenu);
                };
            }, [isSortDropupOpen]);

            const handleSearchChange = (e) => setSearchQuery(e.target.value);

            const shuffleArray = (array) => {
                let currentIndex = array.length, randomIndex;
                while (currentIndex !== 0) {
                    randomIndex = Math.floor(Math.random() * currentIndex);
                    currentIndex--;
                    [array[currentIndex], array[randomIndex]] = [array[randomIndex], array[currentIndex]];
                }
                return array;
            };

            const toggleRepeat = () => {
                setIsRepeating((prevRepeating) => {
                    const newRepeatingState = !prevRepeating;
                    if (newRepeatingState) setIsShuffling(false);
                    if (audioRef.current) audioRef.current.loop = newRepeatingState;
                    return newRepeatingState;
                });
            };

            const toggleShuffle = () => {
                setIsShuffling((prevShuffling) => {
                    const newShufflingState = !prevShuffling;
                    if (newShufflingState) {
                        setIsRepeating(false);
                        if (audioRef.current) audioRef.current.loop = false;
                        setPlaylist((oldPlaylist) => {
                            const currentSong = currentSongIndex !== null ? oldPlaylist[currentSongIndex] : null;
                            const shuffled = shuffleArray([...oldPlaylist.filter(song => song !== currentSong)]);
                            const newPlaylist = currentSong ? [currentSong, ...shuffled] : shuffled;
                            if (currentSong) {
                                const newIdx = newPlaylist.findIndex(s => s === currentSong);
                                setCurrentSongIndex(newIdx);
                            } else if (newPlaylist.length > 0) {
                                setCurrentSongIndex(0);
                            }
                            return newPlaylist;
                        });
                    }
                    return newShufflingState;
                });
            };

            const playNextSong = useCallback(async () => {
                if (playlist.length === 0) return;
                const audio = audioRef.current;
                if (!audio) return;
                // Removed: if (audio.loop && isRepeating) return;
                // Tombol Next harus selalu memutar lagu berikutnya.
                // Logika repeat ditangani oleh handleAudioEnded & audio.loop.

                console.log("playNextSong called.");
                if (audioContextRef.current && audioContextRef.current.state === "suspended") {
                    try {
                        await audioContextRef.current.resume();
                        console.log("AudioContext resumed in playNextSong.");
                    } catch (e) { console.error("Error resuming AudioContext in playNextSong:", e); }
                }

                let nextIndex;
                if (isShuffling) {
                    if (playlist.length <= 1) nextIndex = 0;
                    else {
                        do { nextIndex = Math.floor(Math.random() * playlist.length); }
                        while (playlist.length > 1 && nextIndex === currentSongIndex);
                    }
                } else {
                    nextIndex = (currentSongIndex + 1) % playlist.length;
                }
                setCurrentSongIndex(nextIndex);
                setIsPlaying(true); // Niat untuk memutar lagu berikutnya
            }, [playlist, currentSongIndex, isShuffling, audioRef, audioContextRef]); // isRepeating dihapus karena tidak relevan untuk logika tombol next


            const handleError = useCallback((event) => {
                const audioElement = event.target;
                console.error("Audio playback error event object:", event);
                if (audioElement.error) {
                    console.error("MediaError code:", audioElement.error.code, "Message:", audioElement.error.message);
                } else {
                    console.error("No MediaError object available on the audio element.");
                }
                setIsPlaying(false);
            }, [setIsPlaying]); // setIsPlaying adalah stabil

            useEffect(() => {
                const audio = audioRef.current;
                if (!audio) return;
                const handleTimeUpdate = () => setCurrentTime(audio.currentTime);
                const handleLoadedMetadata = () => setDuration(audio.duration);

                const handleAudioEnded = async () => {
                    console.log("handleAudioEnded: Song finished. isRepeating:", isRepeating);
                    if (!isRepeating) { // Hanya panggil playNextSong jika tidak berulang
                        console.log("handleAudioEnded: Not repeating, calling playNextSong.");
                        await playNextSong();
                    } else {
                        // Jika isRepeating true, audio.loop=true seharusnya sudah menangani loop otomatis.
                        // Pastikan UI tetap sinkron jika perlu.
                        if (audioRef.current && audioRef.current.loop) {
                            // audio.play() mungkin diperlukan di sini jika browser tidak otomatis melanjutkan setelah loop
                            // dan untuk memastikan state isPlaying tetap true.
                            // Namun, useAudioStateSync akan menangani 'play' event jika browser melanjutkan.
                            // Untuk keamanan, kita bisa set isPlaying true lagi di sini.
                            setIsPlaying(true);
                        }
                    }
                };

                audio.addEventListener('timeupdate', handleTimeUpdate);
                audio.addEventListener('loadedmetadata', handleLoadedMetadata);
                audio.addEventListener('ended', handleAudioEnded);
                audio.addEventListener('error', handleError);
                return () => {
                    audio.removeEventListener('timeupdate', handleTimeUpdate);
                    audio.removeEventListener('loadedmetadata', handleLoadedMetadata);
                    audio.removeEventListener('ended', handleAudioEnded);
                    audio.removeEventListener('error', handleError);
                };
            }, [playNextSong, isRepeating, handleError]);


            useEffect(() => {
                const audio = audioRef.current;
                if (!audio) return;

                console.log(`Song loading effect triggered. Index: ${currentSongIndex}, isRepeating: ${isRepeating}`);

                if (currentObjectUrl.current) {
                    URL.revokeObjectURL(currentObjectUrl.current);
                    currentObjectUrl.current = null;
                    console.log("Revoked old object URL");
                }

                if (currentSongIndex !== null && playlist[currentSongIndex]) {
                    const song = playlist[currentSongIndex];
                    console.log(`Loading song: ${song.name}`);
                    const newObjectUrl = URL.createObjectURL(song);
                    currentObjectUrl.current = newObjectUrl;

                    audio.src = newObjectUrl;
                    audio.loop = isRepeating;
                    console.log(`Set audio.src to new ObjectURL. isRepeating: ${isRepeating}, audio.loop: ${audio.loop}`);

                    jsmediatags.read(song, {
                        onSuccess: function (tag) {
                            const title = tag.tags.title || song.name.split('.').slice(0, -1).join('.') || song.name;
                            const artist = tag.tags.artist || '';
                            setSongTitle(title); setSongArtist(artist);
                            if (tag.tags.picture) {
                                const base64String = arrayBufferToBase64(tag.tags.picture.data);
                                setAlbumArtUrl(`data:${tag.tags.picture.format};base64,${base64String}`);
                            } else { setAlbumArtUrl("https://placehold.co/200x200/bec8e4/9baacf?text=No+Art"); }
                        },
                        onError: function (error) {
                            console.error("Error reading media tags:", error);
                            setSongTitle(song.name.split('.').slice(0, -1).join('.') || song.name);
                            setSongArtist(""); setAlbumArtUrl("https://placehold.co/200x200/bec8e4/9baacf?text=No+Art");
                        }
                    });

                    const attemptPlayOnLoad = async () => {
                        // --- FIX: Gunakan isPlayingRef.current ---
                        console.log(`attemptPlayOnLoad: Called. Current isPlaying (from ref): ${isPlayingRef.current}, audio.readyState: ${audio.readyState}, audio.src: ${audio.src ? 'set' : 'not set'}`);
                        if (audioContextRef.current) {
                            console.log(`attemptPlayOnLoad: AudioContext state before resume: ${audioContextRef.current.state}`);
                            if (audioContextRef.current.state === "suspended") {
                                try {
                                    await audioContextRef.current.resume();
                                    console.log("attemptPlayOnLoad: AudioContext resumed successfully.");
                                } catch (e) { console.error("attemptPlayOnLoad: Error resuming AudioContext:", e); }
                            }
                        } else { console.warn("attemptPlayOnLoad: AudioContext ref is null."); }

                        // --- FIX: Gunakan isPlayingRef.current ---
                        if (isPlayingRef.current && audio.src && audio.readyState >= HTMLMediaElement.HAVE_ENOUGH_DATA) {
                            console.log("attemptPlayOnLoad: Conditions met (using ref). Attempting audio.play().");
                            try {
                                await audio.play();
                                console.log("attemptPlayOnLoad: audio.play() promise resolved. Audio should be playing.");
                            } catch (error) {
                                console.error("attemptPlayOnLoad: Error during audio.play(): Name:", error.name, "Message:", error.message);
                                if (error.name === 'NotAllowedError') {
                                    console.warn("Autoplay was prevented by browser policy for the new song.");
                                    setIsPlaying(false); // Update state jika autoplay dicegah
                                }
                                // Error lain akan ditangani oleh listener 'error' global pada elemen audio
                            }
                        } else {
                            let logMessage = "attemptPlayOnLoad: Conditions NOT met for play. ";
                            if (!isPlayingRef.current) logMessage += "isPlaying (from ref) is false. "; // FIX: Gunakan isPlayingRef.current
                            if (!audio.src) logMessage += "audio.src is not set. ";
                            if (audio.readyState < HTMLMediaElement.HAVE_ENOUGH_DATA) logMessage += `audio.readyState is ${audio.readyState}. `;
                            console.log(logMessage);
                        }
                    };

                    const handleCanPlay = () => {
                        setDuration(audio.duration);
                        // --- FIX: Gunakan isPlayingRef.current ---
                        console.log(`handleCanPlay: Song is ready (canplaythrough). isPlaying (from ref): ${isPlayingRef.current}, currentSong: ${song.name}, duration: ${audio.duration}`);
                        if (isPlayingRef.current) { // --- FIX: Gunakan isPlayingRef.current ---
                            attemptPlayOnLoad();
                        }
                    };

                    console.log("Calling audio.load()");
                    audio.load(); // Penting untuk memuat sumber baru
                    audio.addEventListener('canplaythrough', handleCanPlay, { once: true });

                    return () => {
                        console.log("Cleanup song loading effect: Removing canplaythrough listener.");
                        audio.removeEventListener('canplaythrough', handleCanPlay);
                    };

                } else {
                    console.log("No song selected or playlist empty. Clearing audio src.");
                    if (audio.src) audio.src = ""; // Hanya set jika memang ada src sebelumnya
                    // setIsPlaying(false); // useAudioStateSync akan menangani jika audio berhenti
                    setSongTitle("Tidak ada lagu yang sedang diputar");
                    setSongArtist("");
                    setAlbumArtUrl("https://placehold.co/200x200/bec8e4/9baacf?text=No+Art");
                    setCurrentTime(0);
                    setDuration(0);
                }
            }, [currentSongIndex, playlist, isRepeating, audioRef, audioContextRef]); // Dependencies untuk memuat lagu


            const handleFileChange = (event) => {
                const files = Array.from(event.target.files);
                const audioFiles = files.filter(file => file.type.startsWith("audio/") || /\.(mp3|wav|ogg|flac)$/i.test(file.name));
                if (audioFiles.length > 0) {
                    const newPlaylist = isShuffling ? shuffleArray(audioFiles) : audioFiles;
                    setPlaylist(newPlaylist);
                    if (currentSongIndex === null || currentSongIndex >= newPlaylist.length) {
                        setCurrentSongIndex(0);
                        setIsPlaying(false); // Set isPlaying false saat playlist baru dimuat, biarkan pengguna memulai
                    }
                }
                if (fileInputRef.current) fileInputRef.current.value = "";
            };

            const openFolder = () => fileInputRef.current.click();

            const openSingleFile = () => {
                const input = document.createElement("input");
                input.type = "file";
                input.accept = "audio/*, .mp3, .wav, .ogg, .flac";
                input.onchange = (event) => {
                    const file = event.target.files[0];
                    if (file) {
                        setPlaylist((prevPlaylist) => {
                            let updatedPlaylist = [...prevPlaylist, file];
                            if (isShuffling) {
                                const currentSong = currentSongIndex !== null ? updatedPlaylist[currentSongIndex] : null;
                                let filesToShuffle = currentSong ? updatedPlaylist.filter(s => s !== currentSong) : [...updatedPlaylist];
                                filesToShuffle = shuffleArray(filesToShuffle);
                                updatedPlaylist = currentSong ? [currentSong, ...filesToShuffle] : filesToShuffle;
                            }
                            if (currentSongIndex === null && updatedPlaylist.length > 0) {
                                setCurrentSongIndex(0);
                                setIsPlaying(false); // Biarkan pengguna memulai
                            } else if (currentSongIndex !== null && isShuffling) {
                                const currentActualSong = prevPlaylist[currentSongIndex];
                                const newIdx = updatedPlaylist.findIndex(s => s === currentActualSong);
                                if (newIdx !== -1) setCurrentSongIndex(newIdx);
                                else if (updatedPlaylist.length > 0) setCurrentSongIndex(0);
                            }
                            return updatedPlaylist;
                        });
                    }
                };
                input.click();
            };

            const togglePlayPause = useCallback(async () => {
                if (playlist.length === 0 || currentSongIndex === null) {
                    setIsPlaying(false); return;
                }
                const audio = audioRef.current;
                if (!audio) { setIsPlaying(false); return; }
                console.log(`togglePlayPause called. Current isPlaying (from ref): ${isPlayingRef.current}. Audio src: ${audio.src ? 'set' : 'not set'}, readyState: ${audio.readyState}`);
                try {
                    if (audioContextRef.current && audioContextRef.current.state === "suspended") {
                        await audioContextRef.current.resume();
                        console.log("AudioContext resumed in togglePlayPause");
                    }
                    // Gunakan isPlayingRef.current untuk keputusan play/pause
                    if (!isPlayingRef.current) { // Jika ingin PLAY
                        if (audio.src && audio.readyState >= HTMLMediaElement.HAVE_METADATA) {
                            console.log("Attempting to play existing audio source.");
                            await audio.play();
                            // setIsPlaying(true) akan di-set oleh useAudioStateSync
                        } else if (audio.src) {
                            console.log("Audio source exists but not ready. Calling audio.load() and setting isPlaying intent to true.");
                            audio.load();
                            setIsPlaying(true); // Niat untuk play, biarkan canplaythrough menangani
                        } else { setIsPlaying(false); }
                    } else { // Jika ingin PAUSE
                        if (!audio.paused) {
                            console.log("Attempting to pause audio.");
                            audio.pause();
                            // setIsPlaying(false) akan di-set oleh useAudioStateSync
                        }
                    }
                } catch (error) {
                    console.error("Error in togglePlayPause (play/pause attempt):", error);
                    setIsPlaying(false);
                }
            }, [playlist, currentSongIndex, audioRef, audioContextRef]); // isPlaying (state) dihapus, isPlayingRef digunakan di dalam

            const playSong = useCallback(async (indexInFiltered) => {
                const actualIndex = playlist.indexOf(filteredPlaylist[indexInFiltered]);
                if (actualIndex === -1) return;
                const audio = audioRef.current;
                if (!audio) return;
                console.log(`playSong called for index ${actualIndex}. Current index: ${currentSongIndex}`);
                try {
                    if (audioContextRef.current && audioContextRef.current.state === "suspended") {
                        await audioContextRef.current.resume();
                    }
                    if (actualIndex !== currentSongIndex) {
                        setCurrentSongIndex(actualIndex);
                        setIsPlaying(true); // Niat untuk play lagu baru
                    } else {
                        await togglePlayPause(); // Toggle jika lagu yang sama diklik
                    }
                } catch (error) { setIsPlaying(false); }
            }, [playlist, filteredPlaylist, currentSongIndex, togglePlayPause]);

            const playPreviousSong = async () => {
                if (playlist.length === 0) return;
                console.log("playPreviousSong called.");
                if (audioContextRef.current && audioContextRef.current.state === "suspended") {
                    try { await audioContextRef.current.resume(); }
                    catch (e) { console.error("Error resuming context in playPreviousSong", e); }
                }
                let prevIndex;
                if (isShuffling) {
                    if (playlist.length <= 1) prevIndex = 0;
                    else {
                        do { prevIndex = Math.floor(Math.random() * playlist.length); }
                        while (playlist.length > 1 && prevIndex === currentSongIndex);
                    }
                } else { prevIndex = (currentSongIndex - 1 + playlist.length) % playlist.length; }
                setCurrentSongIndex(prevIndex);
                setIsPlaying(true);
            };

            const handleProgressBarChange = (e) => {
                const audio = audioRef.current;
                if (!audio || isNaN(audio.duration) || audio.duration === 0) return;
                const newTime = parseFloat(e.target.value);
                audio.currentTime = newTime;
                // setCurrentTime(newTime); // Diupdate oleh event 'timeupdate'
            };

            const handleVolumeChange = (e) => {
                const newVolume = parseFloat(e.target.value);
                setVolume(newVolume);
            };

            const formatTime = (seconds) => {
                if (isNaN(seconds) || seconds < 0) return "0:00";
                const minutes = Math.floor(seconds / 60);
                const remainingSeconds = Math.floor(seconds % 60);
                return `${minutes}:${remainingSeconds < 10 ? "0" : ""}${remainingSeconds}`;
            };

            const toggleSidebar = () => { setIsSidebarOpen((prevState) => !prevState); setIsEQSidebarOpen(false); };
            const handleCloseBothSidebars = () => { setIsSidebarOpen(false); setIsEQSidebarOpen(false); };

            const handleDeleteSong = (indexToDeleteInOriginal, event) => {
                event.stopPropagation();
                setPlaylist((prevPlaylist) => {
                    const songToDelete = prevPlaylist[indexToDeleteInOriginal];
                    const newPlaylist = prevPlaylist.filter((_, idx) => idx !== indexToDeleteInOriginal);
                    if (newPlaylist.length === 0) {
                        setCurrentSongIndex(null);
                        // setIsPlaying(false); // Akan diurus oleh song loading effect & useAudioStateSync
                    } else if (currentSongIndex === indexToDeleteInOriginal) {
                        const newIndexToPlay = indexToDeleteInOriginal % newPlaylist.length;
                        setCurrentSongIndex(newIndexToPlay);
                        // isPlaying state akan dipertahankan jika sebelumnya true, song loading effect akan mencoba play.
                    } else if (currentSongIndex > indexToDeleteInOriginal) {
                        setCurrentSongIndex(currentSongIndex - 1);
                    }
                    return newPlaylist;
                });
            };

            const clearPlayList = () => {
                setPlaylist([]);
                setCurrentSongIndex(null);
                // setIsPlaying(false); // Akan diurus oleh song loading effect & useAudioStateSync
                setSearchQuery("");
                setIsRepeating(false);
                setIsShuffling(false);
                if (audioRef.current) audioRef.current.loop = false;
                if (fileInputRef.current) fileInputRef.current.value = "";
                setEqSettings({ low: 0, mid: 0, high: 0 });
            };

            return (
                <div className="container">
                    {/* Combined Sidebar Card */}
                    <div
                        className={`playlist-card ${isSidebarOpen || isEQSidebarOpen ? "open" : "collapsed"
                            }`}
                    >
                        <div className="playlist-header">
                            {isSidebarOpen && <h3>Playlist</h3>}
                            {isEQSidebarOpen && <h3>Equalizer</h3>}
                            <div className="header-buttons-group">
                                {isSidebarOpen && (
                                    <button
                                        className="search-toggle-btn"
                                        onClick={handleSearchClick}
                                        aria-label="Search Playlist"
                                    >
                                        <i className="fas fa-search"></i>
                                    </button>
                                )}
                                <button
                                    className="sidebar-toggle-btn"
                                    onClick={
                                        isSidebarOpen || isEQSidebarOpen
                                            ? handleCloseBothSidebars
                                            : toggleSidebar
                                    }
                                    aria-label={
                                        isSidebarOpen || isEQSidebarOpen
                                            ? "Close Sidebars"
                                            : "Open Playlist"
                                    }
                                >
                                    <i
                                        className={`fas ${isSidebarOpen || isEQSidebarOpen
                                            ? "fa-times"
                                            : "fa-bars"
                                            }`}
                                    ></i>
                                </button>
                            </div>
                        </div>

                        {!isSidebarOpen && !isEQSidebarOpen && (
                            <button
                                className={`sidebar-toggle-btn mt-3 ${isEQSidebarOpen ? "eq-button-hidden" : ""
                                    }`}
                                aria-label="Open Equalizer"
                                onClick={toggleEQSidebar}
                            >
                                <i className="fas fa-sliders" aria-hidden="true"></i>
                            </button>
                        )}

                        {isSidebarOpen && !isEQSidebarOpen && (
                            <>
                                {isSearchActive && (
                                    <div className="search-input-container">
                                        <input
                                            type="text"
                                            placeholder="Cari lagu..."
                                            value={searchQuery}
                                            onChange={handleSearchChange}
                                            className="search-input"
                                        />
                                    </div>
                                )}
                                <ul className="playlist-list">
                                    {filteredPlaylist.length === 0 && searchQuery !== "" ? (
                                        <li className="playlist-empty">No matching songs found.</li>
                                    ) : playlist.length === 0 ? (
                                        <li className="playlist-empty">Belum ada lagu yang ditambahkan.</li>
                                    ) : (
                                        filteredPlaylist.map((song, index) => (
                                            <li
                                                key={song.name + index + playlist.indexOf(song)}
                                                className={`playlist-item ${song === playlist[currentSongIndex] ? "active" : ""}`}
                                            >
                                                <div
                                                    className="playlist-item-inner"
                                                    onClick={() => playSong(index)}
                                                >
                                                    <span className="playlist-song-name">
                                                        {song.name.split(".").slice(0, -1).join(".") || song.name}
                                                    </span>
                                                    <button
                                                        className="btn btn__delete"
                                                        onClick={(e) => handleDeleteSong(playlist.indexOf(song), e)}
                                                        aria-label={`Delete ${song.name}`}
                                                    >
                                                        <i className="fas fa-trash-alt"></i>
                                                    </button>
                                                </div>
                                            </li>
                                        ))
                                    )}
                                </ul>
                                <div className="button-container-flex" style={{ marginTop: "auto", paddingTop: "1.5rem" }}>
                                    <button className="btn btn-pl btn__secondary" onClick={openFolder} title="Buka Folder">
                                        <i className="fas fa-folder"></i>
                                    </button>
                                    <button className="btn btn-pl btn__secondary" onClick={openSingleFile} title="Tambahkan File ke Playlist">
                                        <i className="fas fa-file-audio"></i>
                                    </button>
                                    <button className="btn btn-pl btn__secondary" onClick={clearPlayList} title="Bersihkan Playlist">
                                        <i className="fas fa-trash"></i>
                                    </button>
                                    <div className="dropup-container-absolute">
                                        <div className="dropup">
                                            <button className="btn btn-pl btn__secondary dropup-toggle" onClick={toggleSortDropup} title="Urutkan Playlist berdasarkan..." ref={sortButtonRef}>
                                                <i className="fa-solid fa-sort"></i>
                                            </button>
                                            {isSortDropupOpen && (
                                                <div className="dropup-menu" ref={dropupMenuRef} style={{ position: "fixed", zIndex: 1000 }}>
                                                    <button className="dropup-item" onClick={() => sortPlayListBy("title")}>Judul</button>
                                                    <button className="dropup-item" onClick={() => sortPlayListBy("artist")}>Artist</button>
                                                    <button className="dropup-item" onClick={() => sortPlayListBy("dateAdded")}>Tanggal</button>
                                                </div>
                                            )}
                                        </div>
                                    </div>
                                    <button className="btn btn-pl btn__secondary" title="Pengaturan">
                                        <i className="fa-solid fa-gear"></i>
                                    </button>
                                </div>
                            </>
                        )}

                        {isEQSidebarOpen && !isSidebarOpen && (
                            <div className="eq-controls">
                                <div className="eq-band">
                                    <label>Bass</label>
                                    <input type="range" min="-12" max="12" value={eqSettings.low} onChange={(e) => handleEQChange("low", e.target.value)} className="eq-slider" />
                                    <span>{eqSettings.low}dB</span>
                                </div>
                                <div className="eq-band">
                                    <label>Mid</label>
                                    <input type="range" min="-12" max="12" value={eqSettings.mid} onChange={(e) => handleEQChange("mid", e.target.value)} className="eq-slider" />
                                    <span>{eqSettings.mid}dB</span>
                                </div>
                                <div className="eq-band">
                                    <label>Treble</label>
                                    <input type="range" min="-12" max="12" value={eqSettings.high} onChange={(e) => handleEQChange("high", e.target.value)} className="eq-slider" />
                                    <span>{eqSettings.high}dB</span>
                                </div>
                                <button className="btn btn-pl btn__secondary" onClick={() => setEqSettings({ low: 0, mid: 0, high: 0 })} style={{ marginTop: "1rem" }}>
                                    Reset EQ
                                </button>
                            </div>
                        )}

                        {!isSidebarOpen && !isEQSidebarOpen && (
                            <div className="playlist-card-logo mb-3 font-weight-bold">
                                Kyrop<i className="fas fa-compact-disc"></i>d
                            </div>
                        )}

                        <input type="file" webkitdirectory="" directory="" multiple="" ref={fileInputRef} onChange={handleFileChange} style={{ display: "none" }} accept="audio/*,.mp3,.wav,.ogg,.flac" />
                    </div>

                    {/* Main Player Card */}
                    <div className="player-card">
                        <div className="album-art-wrapper">
                            <img src={albumArtUrl} alt="Album Art" className="album-art" onError={(e) => { e.target.onerror = null; e.target.src = "https://placehold.co/200x200/bec8e4/9baacf?text=No+Art"; }} />
                        </div>
                        <div className="song-info">
                            <h2 className={`song-title ${isTitleOverflowing ? "is-scrolling" : ""}`} ref={titleRef} title={songTitle}>
                                <span>{songTitle}{isTitleOverflowing && (<><span className="inline-block" style={{ width: `${gapPixels}px`, display: "inline-block", }}></span>{songTitle}</>)}</span>
                            </h2>
                            <p className={`song-artist ${isArtistOverflowing ? "is-scrolling-artist" : ""}`} ref={artistRef} title={songArtist}>
                                <span>{songArtist}{isArtistOverflowing && (<><span className="inline-block" style={{ width: `${gapPixels}px`, display: "inline-block", }}></span>{songArtist}</>)}</span>
                            </p>
                        </div>

                        <div className="controls-wrapper">
                            <div className="slider">
                                <div className="slider__box">
                                    <input type="range" min="0" max={duration || 0} value={currentTime} onChange={handleProgressBarChange} className="progress-slider" disabled={playlist.length === 0} />
                                    <span className="slider__btn" style={{ left: `${(currentTime / duration) * 100 || 0}%` }}></span>
                                    <span className="slider__color" style={{ width: `${((currentTime / duration) * 100 || 0) + 1}%` }}></span>
                                    <span className="slider__tooltip" style={{ left: `${(currentTime / duration) * 100 || 0}%` }}>{formatTime(currentTime)}</span>
                                </div>
                                <div className="time-display">
                                    <span>{formatTime(currentTime)}</span>
                                    <span>{formatTime(duration)}</span>
                                </div>
                            </div>

                            <div className="player-buttons">
                                <button className={`icon__repeat ${isRepeating ? "active" : ""}`} onClick={toggleRepeat} aria-label="Repeat Song" disabled={playlist.length === 0}>
                                    <i className="fas fa-redo"></i>
                                </button>
                                <button className="icon__prev" onClick={playPreviousSong} aria-label="Previous Song" disabled={playlist.length === 0}>
                                    <i className="fas fa-step-backward"></i>
                                </button>
                                <div className="circle">
                                    <button className={`circle__btn ${isPlaying ? "shadow" : ""}`} onClick={togglePlayPause} aria-label={isPlaying ? "Pause" : "Play"} disabled={playlist.length === 0}>
                                        <i className="fas fa-play"></i>
                                        <i className="fas fa-pause"></i>
                                    </button>
                                    <div className={`circle__back-1 ${isPlaying && playlist.length > 0 ? "" : "paused"}`}></div>
                                    <div className={`circle__back-2 ${isPlaying && playlist.length > 0 ? "" : "paused"}`}></div>
                                </div>
                                <button className="icon__next" onClick={playNextSong} aria-label="Next Song" disabled={playlist.length === 0}>
                                    <i className="fas fa-step-forward"></i>
                                </button>
                                <button className={`icon__shuffle ${isShuffling ? "active" : ""}`} onClick={toggleShuffle} aria-label="Shuffle Playlist" disabled={playlist.length === 0}>
                                    <i className="fas fa-random"></i>
                                </button>
                            </div>

                            <div className="volume-control">
                                <i className="fas fa-volume-down"></i>
                                <input type="range" min="0" max="1" step="0.01" value={volume} onChange={handleVolumeChange} className="volume-slider" aria-label="Volume Slider" disabled={playlist.length === 0} />
                                <i className="fas fa-volume-up"></i>
                            </div>
                        </div>
                    </div>
                    <audio ref={audioRef} preload="metadata"></audio>
                </div>
            );
        }

        ReactDOM.render(<App />, document.getElementById("root"));
    </script>
</body>

</html>