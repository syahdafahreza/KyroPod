<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>KyroPod | By Syahda Fahreza</title>
    <link rel="stylesheet" href="themes/neuromorphic.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css" />
    <link href="fontawesome/css/fontawesome.css" rel="stylesheet" />
    <link href="fontawesome/css/brands.css" rel="stylesheet" />
    <link href="fontawesome/css/solid.css" rel="stylesheet" />
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700&display=swap" rel="stylesheet" />
    <link rel="icon" type="image/svg+xml" href="svg/compact-disc-solid-light.svg"
        media="(prefers-color-scheme: dark)" />
    <link rel="icon" type="image/svg+xml" href="svg/compact-disc-solid-dark.svg"
        media="(prefers-color-scheme: light)" />
    <link rel="icon" type="image/svg+xml" href="svg/compact-disc-solid-light.svg" />
    <link rel="manifest" href="manifest.json" />
    <script src="https://kit.fontawesome.com/b2e4954604.js" crossorigin="anonymous"></script>
    <script>
        if ("serviceWorker" in navigator) {
            window.addEventListener("load", () => {
                navigator.serviceWorker
                    .register("sw.js") // Path to your service worker file
                    .then((registration) => {
                        console.log(
                            "ServiceWorker registration successful with scope: ",
                            registration.scope
                        );
                    })
                    .catch((error) => {
                        console.log("ServiceWorker registration failed: ", error);
                    });
            });
        }
    </script>
</head>

<body>
    <div id="root"></div>

    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jsmediatags@3.9.7/dist/jsmediatags.min.js"></script>

    <script type="text/babel">
        const { useState, useRef, useEffect, useCallback } = React;

        function arrayBufferToBase64(buffer) {
            let binary = '';
            const bytes = new Uint8Array(buffer);
            const len = bytes.byteLength;
            for (let i = 0; i < len; i++) {
                binary += String.fromCharCode(bytes[i]);
            }
            return window.btoa(binary);
        }

        // --- CUSTOM HOOK: useMarquee ---
        const useMarquee = (text, targetRef, gapPixels = 30, speed = 30) => {
            const [isOverflowing, setIsOverflowing] = useState(false);

            useEffect(() => {
                const checkOverflowAndSetMarquee = () => {
                    if (targetRef.current) {
                        const tempSpan = document.createElement("span");
                        tempSpan.style.visibility = "hidden";
                        tempSpan.style.position = "absolute";
                        tempSpan.style.whiteSpace = "nowrap";

                        const computedStyle = getComputedStyle(targetRef.current);
                        tempSpan.style.fontSize = computedStyle.fontSize;
                        tempSpan.style.fontFamily = computedStyle.fontFamily;
                        tempSpan.style.fontWeight = computedStyle.fontWeight;
                        tempSpan.style.letterSpacing = computedStyle.letterSpacing;
                        tempSpan.textContent = text;

                        document.body.appendChild(tempSpan);
                        const singleTextWidth = tempSpan.scrollWidth;
                        document.body.removeChild(tempSpan);

                        const containerWidth = targetRef.current.clientWidth;
                        const overflows = singleTextWidth > containerWidth;

                        setIsOverflowing(overflows);

                        if (overflows) {
                            const distanceToScroll = singleTextWidth + gapPixels;
                            const duration = distanceToScroll / speed;
                            targetRef.current.style.setProperty(
                                "--marquee-duration",
                                `${duration}s`
                            );
                            targetRef.current.style.setProperty(
                                "--marquee-distance",
                                `-${distanceToScroll}px`
                            );
                        } else {
                            targetRef.current.style.setProperty("--marquee-duration", "0s");
                            targetRef.current.style.setProperty(
                                "--marquee-distance",
                                "0px"
                            );
                        }
                    }
                };
                const timeoutId = setTimeout(checkOverflowAndSetMarquee, 100);
                window.addEventListener("resize", checkOverflowAndSetMarquee);
                return () => {
                    clearTimeout(timeoutId);
                    window.removeEventListener("resize", checkOverflowAndSetMarquee);
                };
            }, [text, targetRef, gapPixels, speed]);
            return { isOverflowing };
        };

        const useAudioStateSync = (audioRef, setIsPlaying) => {
            useEffect(() => {
                const audio = audioRef.current;
                if (!audio) return;

                const handlePlay = () => setIsPlaying(true);
                const handlePause = () => setIsPlaying(false);
                const handleEnded = () => setIsPlaying(false);

                audio.addEventListener('play', handlePlay);
                audio.addEventListener('pause', handlePause);
                audio.addEventListener('ended', handleEnded);

                return () => {
                    audio.removeEventListener('play', handlePlay);
                    audio.removeEventListener('pause', handlePause);
                    audio.removeEventListener('ended', handleEnded);
                };
            }, [audioRef, setIsPlaying]);
        };
        // --- END CUSTOM HOOK ---

        function App() {
            // Refs
            const audioRef = useRef(null);
            const fileInputRef = useRef(null);
            const currentObjectUrl = useRef(null);
            const sortButtonRef = useRef(null);
            const dropupMenuRef = useRef(null);

            // Web Audio API refs
            const audioContextRef = useRef(null);
            const sourceNodeRef = useRef(null);
            const gainNodeRef = useRef(null);
            const lowShelfFilterRef = useRef(null);
            const peakingFilterRef = useRef(null);
            const highShelfFilterRef = useRef(null);

            // State Variables
            const [playlist, setPlaylist] = useState([]);
            const [currentSongIndex, setCurrentSongIndex] = useState(null);
            const [isPlaying, setIsPlaying] = useState(false);
            useAudioStateSync(audioRef, setIsPlaying); // Hook untuk sinkronisasi state isPlaying

            const [isRepeating, setIsRepeating] = useState(false);
            const [isShuffling, setIsShuffling] = useState(false);
            const [isBuffering, setIsBuffering] = useState(false);
            const [albumArtUrl, setAlbumArtUrl] = useState(
                "https://placehold.co/200x200/bec8e4/9baacf?text=No+Art"
            );
            const [songTitle, setSongTitle] = useState(
                "Tidak ada lagu yang sedang diputar"
            );
            const [songArtist, setSongArtist] = useState("");
            const [currentTime, setCurrentTime] = useState(0);
            const [duration, setDuration] = useState(0);
            const [volume, setVolume] = useState(0.8);
            const [isSidebarOpen, setIsSidebarOpen] = useState(false);
            const [isEQSidebarOpen, setIsEQSidebarOpen] = useState(false);
            const [isSortDropupOpen, setIsSortDropupOpen] = useState(false);
            const [isSearchActive, setIsSearchActive] = useState(false);
            const [searchQuery, setSearchQuery] = useState("");

            const titleRef = useRef(null);
            const artistRef = useRef(null);

            const [eqSettings, setEqSettings] = useState({
                low: 0,
                mid: 0,
                high: 0,
            });

            const gapPixels = 30;
            const { isOverflowing: isTitleOverflowing } = useMarquee(songTitle, titleRef, gapPixels);
            const { isOverflowing: isArtistOverflowing } = useMarquee(songArtist, artistRef, gapPixels);

            const filteredPlaylist = playlist.filter((song) =>
                song.name.toLowerCase().includes(searchQuery.toLowerCase())
            );

            useEffect(() => {
                const audio = audioRef.current;
                if (!audio) return;
                const handleWaiting = () => setIsBuffering(true);
                const handlePlaying = () => setIsBuffering(false);
                audio.addEventListener('waiting', handleWaiting);
                audio.addEventListener('playing', handlePlaying);
                return () => {
                    audio.removeEventListener('waiting', handleWaiting);
                    audio.removeEventListener('playing', handlePlaying);
                };
            }, []);

            const toggleEQSidebar = () => {
                setIsEQSidebarOpen((prevState) => !prevState);
                setIsSidebarOpen(false);
                if (
                    !isEQSidebarOpen &&
                    audioContextRef.current &&
                    audioContextRef.current.state === "suspended"
                ) {
                    audioContextRef.current
                        .resume()
                        .catch((e) => console.error("Error resuming AudioContext:", e));
                }
            };

            const handleEQChange = useCallback((band, value) => {
                setEqSettings((prevSettings) => ({
                    ...prevSettings,
                    [band]: parseFloat(value),
                }));
            }, []);

            // Inisialisasi AudioContext dan node-node nya
            useEffect(() => {
                const audio = audioRef.current;
                if (!audio) return;

                if (!audioContextRef.current) {
                    audioContextRef.current = new (window.AudioContext || window.webkitAudioContext)();
                }
                const audioContext = audioContextRef.current;

                // Periksa apakah sourceNode sudah ada dan apakah elemen audio sama
                // Ini penting untuk menghindari error "Cannot create MediaElementSource for an HTMLMediaElement having non-null srcObject"
                // atau "InvalidStateNode" jika source sudah ada.
                if (!sourceNodeRef.current || sourceNodeRef.current.mediaElement !== audio) {
                    if (sourceNodeRef.current) { // Putuskan koneksi source lama jika ada
                        sourceNodeRef.current.disconnect();
                    }
                    try {
                        sourceNodeRef.current = audioContext.createMediaElementSource(audio);
                    } catch (e) {
                        console.error("Error creating MediaElementSource:", e);
                        return;
                    }
                }

                if (!gainNodeRef.current) {
                    gainNodeRef.current = audioContext.createGain();
                    gainNodeRef.current.gain.value = volume;
                }
                if (!lowShelfFilterRef.current) {
                    lowShelfFilterRef.current = audioContext.createBiquadFilter();
                    lowShelfFilterRef.current.type = "lowshelf";
                    lowShelfFilterRef.current.frequency.value = 250;
                }
                if (!peakingFilterRef.current) {
                    peakingFilterRef.current = audioContext.createBiquadFilter();
                    peakingFilterRef.current.type = "peaking";
                    peakingFilterRef.current.frequency.value = 1500;
                    peakingFilterRef.current.Q.value = 1; // Default Q, bisa disesuaikan
                }
                if (!highShelfFilterRef.current) {
                    highShelfFilterRef.current = audioContext.createBiquadFilter();
                    highShelfFilterRef.current.type = "highshelf";
                    highShelfFilterRef.current.frequency.value = 4000;
                }

                // Selalu putuskan koneksi lama sebelum menyambungkan kembali untuk menghindari duplikasi
                sourceNodeRef.current.disconnect();
                gainNodeRef.current.disconnect();
                lowShelfFilterRef.current.disconnect();
                peakingFilterRef.current.disconnect();
                // highShelfFilterRef.current tidak perlu disconnect() dari node sebelumnya karena ia adalah yang terakhir sebelum destination

                try {
                    sourceNodeRef.current.connect(gainNodeRef.current);
                    gainNodeRef.current.connect(lowShelfFilterRef.current);
                    lowShelfFilterRef.current.connect(peakingFilterRef.current);
                    peakingFilterRef.current.connect(highShelfFilterRef.current);
                    highShelfFilterRef.current.connect(audioContext.destination);
                } catch (e) {
                    console.error("Error connecting audio nodes:", e);
                }
            }, []); // Hanya berjalan sekali saat mount

            useEffect(() => {
                if (!lowShelfFilterRef.current || !peakingFilterRef.current || !highShelfFilterRef.current) return;
                lowShelfFilterRef.current.gain.value = eqSettings.low;
                peakingFilterRef.current.gain.value = eqSettings.mid;
                highShelfFilterRef.current.gain.value = eqSettings.high;
            }, [eqSettings]);

            useEffect(() => {
                if (gainNodeRef.current) {
                    gainNodeRef.current.gain.value = volume;
                }
            }, [volume]);

            const handleSearchClick = () => {
                setIsSearchActive((prev) => !prev);
                if (isSearchActive) setSearchQuery("");
            };
            const toggleSortDropup = () => setIsSortDropupOpen((prev) => !prev);

            const sortPlayListBy = (criteria) => {
                setPlaylist((prevPlaylist) => {
                    const newPlaylist = [...prevPlaylist];
                    newPlaylist.sort((a, b) => {
                        let valA, valB;
                        if (criteria === "title") {
                            valA = (a.name || "").toLowerCase();
                            valB = (b.name || "").toLowerCase();
                        } else if (criteria === "artist") {
                            valA = (a.metadata?.artist || a.name || "").toLowerCase();
                            valB = (b.metadata?.artist || b.name || "").toLowerCase();
                        } else if (criteria === "dateAdded") {
                            valA = a.lastModified;
                            valB = b.lastModified;
                        }
                        if (valA < valB) return -1;
                        if (valA > valB) return 1;
                        return 0;
                    });
                    return newPlaylist;
                });
                setIsSortDropupOpen(false);
            };

            useEffect(() => {
                const handleClickOutside = (event) => {
                    if (isSortDropupOpen && dropupMenuRef.current && !dropupMenuRef.current.contains(event.target) && sortButtonRef.current && !sortButtonRef.current.contains(event.target)) {
                        setIsSortDropupOpen(false);
                    }
                };
                const positionDropupMenu = () => {
                    if (isSortDropupOpen && sortButtonRef.current && dropupMenuRef.current) {
                        const buttonRect = sortButtonRef.current.getBoundingClientRect();
                        const menuElement = dropupMenuRef.current;
                        menuElement.style.top = `${buttonRect.top - menuElement.offsetHeight - 10}px`;
                        menuElement.style.left = `${buttonRect.left}px`;
                        menuElement.style.minWidth = `${buttonRect.width}px`;
                    }
                };
                if (isSortDropupOpen) {
                    document.addEventListener("mousedown", handleClickOutside);
                    window.addEventListener("resize", positionDropupMenu);
                    window.addEventListener("scroll", positionDropupMenu);
                    setTimeout(positionDropupMenu, 0);
                }
                return () => {
                    document.removeEventListener("mousedown", handleClickOutside);
                    window.removeEventListener("resize", positionDropupMenu);
                    window.removeEventListener("scroll", positionDropupMenu);
                };
            }, [isSortDropupOpen]);

            const handleSearchChange = (e) => setSearchQuery(e.target.value);

            const shuffleArray = (array) => {
                let currentIndex = array.length, randomIndex;
                while (currentIndex !== 0) {
                    randomIndex = Math.floor(Math.random() * currentIndex);
                    currentIndex--;
                    [array[currentIndex], array[randomIndex]] = [array[randomIndex], array[currentIndex]];
                }
                return array;
            };

            const toggleRepeat = () => {
                setIsRepeating((prevRepeating) => {
                    const newRepeatingState = !prevRepeating;
                    if (newRepeatingState) setIsShuffling(false);
                    if (audioRef.current) audioRef.current.loop = newRepeatingState;
                    return newRepeatingState;
                });
            };

            const toggleShuffle = () => {
                setIsShuffling((prevShuffling) => {
                    const newShufflingState = !prevShuffling;
                    if (newShufflingState) {
                        setIsRepeating(false);
                        if (audioRef.current) audioRef.current.loop = false;
                        setPlaylist((oldPlaylist) => {
                            const currentSong = currentSongIndex !== null ? oldPlaylist[currentSongIndex] : null;
                            const shuffled = shuffleArray([...oldPlaylist.filter(song => song !== currentSong)]);
                            const newPlaylist = currentSong ? [currentSong, ...shuffled] : shuffled;
                            if (currentSong) {
                                const newIdx = newPlaylist.findIndex(s => s === currentSong);
                                setCurrentSongIndex(newIdx);
                            } else if (newPlaylist.length > 0) {
                                setCurrentSongIndex(0);
                            }
                            return newPlaylist;
                        });
                    }
                    return newShufflingState;
                });
            };

            const playNextSong = useCallback(() => {
                if (playlist.length === 0) return;
                const audio = audioRef.current;
                if (!audio) return;
                if (audio.loop) return;

                let nextIndex;
                if (isShuffling) {
                    if (playlist.length <= 1) nextIndex = 0;
                    else {
                        do { nextIndex = Math.floor(Math.random() * playlist.length); }
                        while (playlist.length > 1 && nextIndex === currentSongIndex);
                    }
                } else {
                    nextIndex = (currentSongIndex + 1) % playlist.length;
                }
                setCurrentSongIndex(nextIndex);
                // setIsPlaying(true); // Biarkan song loading effect yang menangani play
                // atau togglePlayPause jika pengguna mengklik tombol play secara eksplisit.
                // Namun, untuk playNext, biasanya kita ingin langsung play.
                // Untuk memastikan play, kita set isPlaying true, dan song loading effect akan play.
                setIsPlaying(true);
            }, [playlist, currentSongIndex, isShuffling, isRepeating]);


            useEffect(() => {
                const audio = audioRef.current;
                if (!audio) return;
                const handleTimeUpdate = () => setCurrentTime(audio.currentTime);
                const handleLoadedMetadata = () => setDuration(audio.duration);
                const handleAudioEnded = () => {
                    if (!isRepeating) playNextSong();
                };
                const handleError = (error) => {
                    console.error("Audio playback error:", error);
                    setIsPlaying(false);
                };
                audio.addEventListener('timeupdate', handleTimeUpdate);
                audio.addEventListener('loadedmetadata', handleLoadedMetadata);
                audio.addEventListener('ended', handleAudioEnded);
                audio.addEventListener('error', handleError);
                return () => {
                    audio.removeEventListener('timeupdate', handleTimeUpdate);
                    audio.removeEventListener('loadedmetadata', handleLoadedMetadata);
                    audio.removeEventListener('ended', handleAudioEnded);
                    audio.removeEventListener('error', handleError);
                };
            }, [playNextSong, isRepeating]);

            // *** MODIFIED useEffect for loading song ***
            useEffect(() => {
                const audio = audioRef.current;
                if (!audio) return;

                if (currentObjectUrl.current) {
                    URL.revokeObjectURL(currentObjectUrl.current);
                    currentObjectUrl.current = null;
                }

                if (currentSongIndex !== null && playlist[currentSongIndex]) {
                    const song = playlist[currentSongIndex];
                    const newObjectUrl = URL.createObjectURL(song);
                    currentObjectUrl.current = newObjectUrl;
                    audio.src = newObjectUrl;
                    audio.loop = isRepeating;

                    jsmediatags.read(song, {
                        onSuccess: function (tag) {
                            const title = tag.tags.title || song.name.split('.').slice(0, -1).join('.') || song.name;
                            const artist = tag.tags.artist || '';
                            setSongTitle(title);
                            setSongArtist(artist);
                            if (tag.tags.picture) {
                                const base64String = arrayBufferToBase64(tag.tags.picture.data);
                                setAlbumArtUrl(`data:${tag.tags.picture.format};base64,${base64String}`);
                            } else {
                                setAlbumArtUrl("https://placehold.co/200x200/bec8e4/9baacf?text=No+Art");
                            }
                        },
                        onError: function (error) {
                            console.error("Error reading media tags:", error);
                            setSongTitle(song.name.split('.').slice(0, -1).join('.') || song.name);
                            setSongArtist("");
                            setAlbumArtUrl("https://placehold.co/200x200/bec8e4/9baacf?text=No+Art");
                        }
                    });

                    // Fungsi untuk mencoba memainkan audio setelah siap
                    const attemptPlayOnLoad = async () => {
                        try {
                            // Selalu coba resume AudioContext sebelum play, penting untuk mobile
                            if (audioContextRef.current && audioContextRef.current.state === "suspended") {
                                await audioContextRef.current.resume();
                                console.log("AudioContext resumed in attemptPlayOnLoad (song load effect)");
                            }
                            // Hanya coba play jika isPlaying true dan audio memiliki cukup data
                            if (isPlaying && audio.readyState >= HTMLMediaElement.HAVE_ENOUGH_DATA) { // HAVE_ENOUGH_DATA lebih ketat
                                await audio.play();
                            } else if (isPlaying) {
                                console.log("Song load effect: isPlaying true, but audio not ready enough. Play will be attempted by canplaythrough or direct play command.");
                            }
                        } catch (error) {
                            console.error("Autoplay error in song load effect:", error);
                            setIsPlaying(false); // Koreksi state jika autoplay gagal
                        }
                    };

                    const handleCanPlay = () => {
                        setDuration(audio.duration);
                        if (isPlaying) { // Jika state mengindikasikan harus play
                            attemptPlayOnLoad();
                        }
                    };

                    audio.load(); // Panggil load() setelah src di-set
                    // Menggunakan 'canplaythrough' mungkin lebih baik untuk mobile untuk memastikan buffering cukup
                    audio.addEventListener('canplaythrough', handleCanPlay, { once: true });

                    return () => {
                        audio.removeEventListener('canplaythrough', handleCanPlay);
                    };

                } else {
                    audio.src = "";
                    setIsPlaying(false);
                    setSongTitle("Tidak ada lagu yang sedang diputar");
                    setSongArtist("");
                    setAlbumArtUrl("https://placehold.co/200x200/bec8e4/9baacf?text=No+Art");
                    setCurrentTime(0);
                    setDuration(0);
                }
            }, [currentSongIndex, playlist, isRepeating]); // isPlaying DIHAPUS dari dependensi ini, karena efek ini tentang MEMUAT lagu.
            // Keputusan untuk PLAY setelah load bergantung pada state isPlaying saat itu.

            // useEffect untuk play/pause berdasarkan isPlaying SUDAH TIDAK DIPERLUKAN LAGI
            // karena togglePlayPause dan attemptPlayOnLoad di song loading effect menanganinya.
            // useAudioStateSync akan menjaga isPlaying tetap sinkron dengan event audio element.

            const handleFileChange = (event) => {
                const files = Array.from(event.target.files);
                const audioFiles = files.filter(file => file.type.startsWith("audio/") || /\.(mp3|wav|ogg|flac)$/i.test(file.name));
                if (audioFiles.length > 0) {
                    const newPlaylist = isShuffling ? shuffleArray(audioFiles) : audioFiles;
                    setPlaylist(newPlaylist);
                    if (currentSongIndex === null || currentSongIndex >= newPlaylist.length) {
                        setCurrentSongIndex(0);
                        // Jika sebelumnya tidak ada lagu atau indeks tidak valid, mainkan lagu pertama jika isPlaying true
                        // Jika tidak, biarkan paused.
                        // Jika isPlaying sudah true, song loading effect akan mencoba memainkannya.
                    }
                }
                if (fileInputRef.current) fileInputRef.current.value = "";
            };

            const openFolder = () => fileInputRef.current.click();

            const openSingleFile = () => {
                const input = document.createElement("input");
                input.type = "file";
                input.accept = "audio/*, .mp3, .wav, .ogg, .flac";
                input.onchange = (event) => {
                    const file = event.target.files[0];
                    if (file) {
                        setPlaylist((prevPlaylist) => {
                            let updatedPlaylist = [...prevPlaylist, file];
                            if (isShuffling) {
                                const currentSong = currentSongIndex !== null ? updatedPlaylist[currentSongIndex] : null;
                                let filesToShuffle = currentSong ? updatedPlaylist.filter(s => s !== currentSong) : [...updatedPlaylist];
                                filesToShuffle = shuffleArray(filesToShuffle);
                                updatedPlaylist = currentSong ? [currentSong, ...filesToShuffle] : filesToShuffle;
                            }
                            if (currentSongIndex === null && updatedPlaylist.length > 0) {
                                setCurrentSongIndex(0);
                            } else if (currentSongIndex !== null && isShuffling) {
                                const currentActualSong = prevPlaylist[currentSongIndex];
                                const newIdx = updatedPlaylist.findIndex(s => s === currentActualSong);
                                if (newIdx !== -1) setCurrentSongIndex(newIdx);
                                else if (updatedPlaylist.length > 0) setCurrentSongIndex(0);
                            }
                            return updatedPlaylist;
                        });
                    }
                };
                input.click();
            };

            // *** MODIFIED togglePlayPause ***
            const togglePlayPause = useCallback(async () => {
                if (playlist.length === 0 || currentSongIndex === null) {
                    setIsPlaying(false);
                    return;
                }
                const audio = audioRef.current;
                if (!audio) {
                    console.warn("togglePlayPause: audioRef.current is null");
                    setIsPlaying(false);
                    return;
                }

                try {
                    // Selalu coba resume AudioContext, terutama untuk interaksi pertama di mobile
                    if (audioContextRef.current && audioContextRef.current.state === "suspended") {
                        await audioContextRef.current.resume();
                        console.log("AudioContext resumed in togglePlayPause");
                    }

                    if (!isPlaying) { // Jika ingin PLAY
                        if (audio.src && audio.readyState >= HTMLMediaElement.HAVE_METADATA) { // Pastikan src ada & metadata siap
                            await audio.play();
                            // setIsPlaying(true); // useAudioStateSync akan menangani ini dari event 'play'
                        } else if (audio.src) {
                            // src ada tapi belum siap, coba load dan biarkan canplaythrough menangani play
                            audio.load();
                            setIsPlaying(true); // Set intent untuk play, biarkan song effect yg handle
                            console.log("togglePlayPause: Audio not fully ready, set isPlaying true, relying on canplaythrough.");
                        } else {
                            console.warn("togglePlayPause: No audio source to play.");
                            setIsPlaying(false);
                        }
                    } else { // Jika ingin PAUSE
                        if (!audio.paused) {
                            audio.pause();
                        }
                        // setIsPlaying(false); // useAudioStateSync akan menangani ini dari event 'pause'
                    }
                } catch (error) {
                    console.error("Error in togglePlayPause (play/pause attempt):", error);
                    setIsPlaying(false); // Jika error, pastikan state isPlaying false
                }
            }, [playlist, currentSongIndex, isPlaying, audioRef]); // isPlaying sekarang jadi dependency

            // *** MODIFIED playSong ***
            const playSong = useCallback(async (indexInFiltered) => {
                const actualIndex = playlist.indexOf(filteredPlaylist[indexInFiltered]);
                if (actualIndex === -1) return;

                const audio = audioRef.current;
                if (!audio) return;

                try {
                    // Selalu coba resume AudioContext
                    if (audioContextRef.current && audioContextRef.current.state === "suspended") {
                        await audioContextRef.current.resume();
                        console.log("AudioContext resumed in playSong");
                    }

                    if (actualIndex !== currentSongIndex) {
                        setCurrentSongIndex(actualIndex);
                        setIsPlaying(true); // Set intent untuk play, song loading effect akan menangani play aktual
                    } else {
                        // Jika lagu yang sama diklik, panggil togglePlayPause
                        await togglePlayPause();
                    }
                } catch (error) {
                    console.error("Error in playSong:", error);
                    setIsPlaying(false);
                }
            }, [playlist, filteredPlaylist, currentSongIndex, togglePlayPause]); // togglePlayPause ditambahkan sbg dependency


            const playPreviousSong = async () => { // Jadikan async untuk konsistensi jika ada await di dalamnya
                if (playlist.length === 0) return;
                let prevIndex;
                if (isShuffling) {
                    if (playlist.length <= 1) prevIndex = 0;
                    else {
                        do { prevIndex = Math.floor(Math.random() * playlist.length); }
                        while (playlist.length > 1 && prevIndex === currentSongIndex);
                    }
                } else {
                    prevIndex = (currentSongIndex - 1 + playlist.length) % playlist.length;
                }

                // Coba resume context sebelum mengganti lagu
                if (audioContextRef.current && audioContextRef.current.state === "suspended") {
                    try {
                        await audioContextRef.current.resume();
                        console.log("AudioContext resumed in playPreviousSong");
                    } catch (e) {
                        console.error("Error resuming context in playPreviousSong", e);
                    }
                }

                setCurrentSongIndex(prevIndex);
                setIsPlaying(true); // Set intent untuk play
            };

            const handleProgressBarChange = (e) => {
                const audio = audioRef.current;
                if (!audio || isNaN(audio.duration)) return;
                const newTime = parseFloat(e.target.value);
                audio.currentTime = newTime;
            };

            const handleVolumeChange = (e) => {
                const newVolume = parseFloat(e.target.value);
                setVolume(newVolume);
            };

            const formatTime = (seconds) => {
                if (isNaN(seconds) || seconds < 0) return "0:00";
                const minutes = Math.floor(seconds / 60);
                const remainingSeconds = Math.floor(seconds % 60);
                return `${minutes}:${remainingSeconds < 10 ? "0" : ""}${remainingSeconds}`;
            };

            const toggleSidebar = () => {
                setIsSidebarOpen((prevState) => !prevState);
                setIsEQSidebarOpen(false);
            };
            const handleCloseBothSidebars = () => {
                setIsSidebarOpen(false);
                setIsEQSidebarOpen(false);
            };

            const handleDeleteSong = (indexToDeleteInOriginal, event) => {
                event.stopPropagation();
                setPlaylist((prevPlaylist) => {
                    const newPlaylist = prevPlaylist.filter((_, idx) => idx !== indexToDeleteInOriginal);
                    if (newPlaylist.length === 0) {
                        setCurrentSongIndex(null);
                    } else if (currentSongIndex === indexToDeleteInOriginal) {
                        setCurrentSongIndex(indexToDeleteInOriginal % newPlaylist.length);
                    } else if (currentSongIndex > indexToDeleteInOriginal) {
                        setCurrentSongIndex(currentSongIndex - 1);
                    }
                    return newPlaylist;
                });
            };

            const clearPlayList = () => {
                setPlaylist([]);
                setCurrentSongIndex(null);
                setSearchQuery("");
                setIsRepeating(false);
                setIsShuffling(false);
                if (audioRef.current) audioRef.current.loop = false;
                if (fileInputRef.current) fileInputRef.current.value = "";
                setEqSettings({ low: 0, mid: 0, high: 0 });
            };

            return (
                <div className="container">
                    {/* Combined Sidebar Card */}
                    <div
                        className={`playlist-card ${isSidebarOpen || isEQSidebarOpen ? "open" : "collapsed"
                            }`}
                    >
                        <div className="playlist-header">
                            {isSidebarOpen && <h3>Playlist</h3>}
                            {isEQSidebarOpen && <h3>Equalizer</h3>}
                            <div className="header-buttons-group">
                                {isSidebarOpen && (
                                    <button
                                        className="search-toggle-btn"
                                        onClick={handleSearchClick}
                                        aria-label="Search Playlist"
                                    >
                                        <i className="fas fa-search"></i>
                                    </button>
                                )}
                                <button
                                    className="sidebar-toggle-btn"
                                    onClick={
                                        isSidebarOpen || isEQSidebarOpen
                                            ? handleCloseBothSidebars
                                            : toggleSidebar
                                    }
                                    aria-label={
                                        isSidebarOpen || isEQSidebarOpen
                                            ? "Close Sidebars"
                                            : "Open Playlist"
                                    }
                                >
                                    <i
                                        className={`fas ${isSidebarOpen || isEQSidebarOpen
                                            ? "fa-times"
                                            : "fa-bars"
                                            }`}
                                    ></i>
                                </button>
                            </div>
                        </div>

                        {!isSidebarOpen && !isEQSidebarOpen && (
                            <button
                                className={`sidebar-toggle-btn mt-3 ${isEQSidebarOpen ? "eq-button-hidden" : ""
                                    }`}
                                aria-label="Open Equalizer"
                                onClick={toggleEQSidebar}
                            >
                                <i className="fas fa-sliders" aria-hidden="true"></i>
                            </button>
                        )}

                        {isSidebarOpen && !isEQSidebarOpen && (
                            <>
                                {isSearchActive && (
                                    <div className="search-input-container">
                                        <input
                                            type="text"
                                            placeholder="Cari lagu..."
                                            value={searchQuery}
                                            onChange={handleSearchChange}
                                            className="search-input"
                                        />
                                    </div>
                                )}
                                <ul className="playlist-list">
                                    {filteredPlaylist.length === 0 && searchQuery !== "" ? (
                                        <li className="playlist-empty">No matching songs found.</li>
                                    ) : playlist.length === 0 ? (
                                        <li className="playlist-empty">Belum ada lagu yang ditambahkan.</li>
                                    ) : (
                                        filteredPlaylist.map((song, index) => (
                                            <li
                                                key={song.name + index + playlist.indexOf(song)}
                                                className={`playlist-item ${song === playlist[currentSongIndex] ? "active" : ""}`}
                                            >
                                                <div
                                                    className="playlist-item-inner"
                                                    onClick={() => playSong(index)} // playSong sudah useCallback
                                                >
                                                    <span className="playlist-song-name">
                                                        {song.name.split(".").slice(0, -1).join(".") || song.name}
                                                    </span>
                                                    <button
                                                        className="btn btn__delete"
                                                        onClick={(e) => handleDeleteSong(playlist.indexOf(song), e)}
                                                        aria-label={`Delete ${song.name}`}
                                                    >
                                                        <i className="fas fa-trash-alt"></i>
                                                    </button>
                                                </div>
                                            </li>
                                        ))
                                    )}
                                </ul>
                                <div className="button-container-flex" style={{ marginTop: "auto", paddingTop: "1.5rem" }}>
                                    <button className="btn btn-pl btn__secondary" onClick={openFolder} title="Buka Folder">
                                        <i className="fas fa-folder"></i>
                                    </button>
                                    <button className="btn btn-pl btn__secondary" onClick={openSingleFile} title="Tambahkan File ke Playlist">
                                        <i className="fas fa-file-audio"></i>
                                    </button>
                                    <button className="btn btn-pl btn__secondary" onClick={clearPlayList} title="Bersihkan Playlist">
                                        <i className="fas fa-trash"></i>
                                    </button>
                                    <div className="dropup-container-absolute">
                                        <div className="dropup">
                                            <button className="btn btn-pl btn__secondary dropup-toggle" onClick={toggleSortDropup} title="Urutkan Playlist berdasarkan..." ref={sortButtonRef}>
                                                <i className="fa-solid fa-sort"></i>
                                            </button>
                                            {isSortDropupOpen && (
                                                <div className="dropup-menu" ref={dropupMenuRef} style={{ position: "fixed", zIndex: 1000 }}>
                                                    <button className="dropup-item" onClick={() => sortPlayListBy("title")}>Judul</button>
                                                    <button className="dropup-item" onClick={() => sortPlayListBy("artist")}>Artist</button>
                                                    <button className="dropup-item" onClick={() => sortPlayListBy("dateAdded")}>Tanggal</button>
                                                </div>
                                            )}
                                        </div>
                                    </div>
                                    <button className="btn btn-pl btn__secondary" title="Pengaturan">
                                        <i className="fa-solid fa-gear"></i>
                                    </button>
                                </div>
                            </>
                        )}

                        {isEQSidebarOpen && !isSidebarOpen && (
                            <div className="eq-controls">
                                <div className="eq-band">
                                    <label>Bass</label>
                                    <input type="range" min="-12" max="12" value={eqSettings.low} onChange={(e) => handleEQChange("low", e.target.value)} className="eq-slider" />
                                    <span>{eqSettings.low}dB</span>
                                </div>
                                <div className="eq-band">
                                    <label>Mid</label>
                                    <input type="range" min="-12" max="12" value={eqSettings.mid} onChange={(e) => handleEQChange("mid", e.target.value)} className="eq-slider" />
                                    <span>{eqSettings.mid}dB</span>
                                </div>
                                <div className="eq-band">
                                    <label>Treble</label>
                                    <input type="range" min="-12" max="12" value={eqSettings.high} onChange={(e) => handleEQChange("high", e.target.value)} className="eq-slider" />
                                    <span>{eqSettings.high}dB</span>
                                </div>
                                <button className="btn btn-pl btn__secondary" onClick={() => setEqSettings({ low: 0, mid: 0, high: 0 })} style={{ marginTop: "1rem" }}>
                                    Reset EQ
                                </button>
                            </div>
                        )}

                        {!isSidebarOpen && !isEQSidebarOpen && (
                            <div className="playlist-card-logo mb-3 font-weight-bold">
                                Kyrop<i className="fas fa-compact-disc"></i>d
                            </div>
                        )}

                        <input type="file" webkitdirectory="" directory="" multiple="" ref={fileInputRef} onChange={handleFileChange} style={{ display: "none" }} accept="audio/*,.mp3,.wav,.ogg,.flac" />
                    </div>

                    {/* Main Player Card */}
                    <div className="player-card">
                        <div className="album-art-wrapper">
                            <img src={albumArtUrl} alt="Album Art" className="album-art" onError={(e) => { e.target.onerror = null; e.target.src = "https://placehold.co/200x200/bec8e4/9baacf?text=No+Art"; }} />
                        </div>
                        <div className="song-info">
                            <h2 className={`song-title ${isTitleOverflowing ? "is-scrolling" : ""}`} ref={titleRef} title={songTitle}>
                                <span>{songTitle}{isTitleOverflowing && (<><span className="inline-block" style={{ width: `${gapPixels}px`, display: "inline-block", }}></span>{songTitle}</>)}</span>
                            </h2>
                            <p className={`song-artist ${isArtistOverflowing ? "is-scrolling-artist" : ""}`} ref={artistRef} title={songArtist}>
                                <span>{songArtist}{isArtistOverflowing && (<><span className="inline-block" style={{ width: `${gapPixels}px`, display: "inline-block", }}></span>{songArtist}</>)}</span>
                            </p>
                        </div>

                        <div className="controls-wrapper">
                            <div className="slider">
                                <div className="slider__box">
                                    <input type="range" min="0" max={duration || 0} value={currentTime} onChange={handleProgressBarChange} className="progress-slider" disabled={playlist.length === 0} />
                                    <span className="slider__btn" style={{ left: `${(currentTime / duration) * 100 || 0}%` }}></span>
                                    <span className="slider__color" style={{ width: `${((currentTime / duration) * 100 || 0) + 1}%` }}></span>
                                    <span className="slider__tooltip" style={{ left: `${(currentTime / duration) * 100 || 0}%` }}>{formatTime(currentTime)}</span>
                                </div>
                                <div className="time-display">
                                    <span>{formatTime(currentTime)}</span>
                                    <span>{formatTime(duration)}</span>
                                </div>
                            </div>

                            <div className="player-buttons">
                                <button className={`icon__repeat ${isRepeating ? "active" : ""}`} onClick={toggleRepeat} aria-label="Repeat Song" disabled={playlist.length === 0}>
                                    <i className="fas fa-redo"></i>
                                </button>
                                <button className="icon__prev" onClick={playPreviousSong} aria-label="Previous Song" disabled={playlist.length === 0}>
                                    <i className="fas fa-step-backward"></i>
                                </button>
                                <div className="circle">
                                    <button className={`circle__btn ${isPlaying ? "shadow" : ""}`} onClick={togglePlayPause} aria-label={isPlaying ? "Pause" : "Play"} disabled={playlist.length === 0}>
                                        <i className="fas fa-play"></i>
                                        <i className="fas fa-pause"></i>
                                    </button>
                                    <div className={`circle__back-1 ${isPlaying && playlist.length > 0 ? "" : "paused"}`}></div>
                                    <div className={`circle__back-2 ${isPlaying && playlist.length > 0 ? "" : "paused"}`}></div>
                                </div>
                                <button className="icon__next" onClick={playNextSong} aria-label="Next Song" disabled={playlist.length === 0}>
                                    <i className="fas fa-step-forward"></i>
                                </button>
                                <button className={`icon__shuffle ${isShuffling ? "active" : ""}`} onClick={toggleShuffle} aria-label="Shuffle Playlist" disabled={playlist.length === 0}>
                                    <i className="fas fa-random"></i>
                                </button>
                            </div>

                            <div className="volume-control">
                                <i className="fas fa-volume-down"></i>
                                <input type="range" min="0" max="1" step="0.01" value={volume} onChange={handleVolumeChange} className="volume-slider" aria-label="Volume Slider" disabled={playlist.length === 0} />
                                <i className="fas fa-volume-up"></i>
                            </div>
                        </div>
                    </div>
                    {/* preload="metadata" penting agar durasi dan info lain bisa didapat sebelum play */}
                    <audio ref={audioRef} preload="metadata"></audio>
                </div>
            );
        }

        ReactDOM.render(<App />, document.getElementById("root"));
    </script>
</body>

</html>