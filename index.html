<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>KyroPod | By Syahda Fahreza</title>
    <link rel="stylesheet" href="themes/neuromorphic.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css" />
    <link href="fontawesome/css/fontawesome.css" rel="stylesheet" />
    <link href="fontawesome/css/brands.css" rel="stylesheet" />
    <link href="fontawesome/css/solid.css" rel="stylesheet" />
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700&display=swap" rel="stylesheet" />
    <link rel="icon" type="image/svg+xml" href="svg/compact-disc-solid-light.svg"
        media="(prefers-color-scheme: dark)" />
    <link rel="icon" type="image/svg+xml" href="svg/compact-disc-solid-dark.svg"
        media="(prefers-color-scheme: light)" />
    <link rel="icon" type="image/svg+xml" href="svg/compact-disc-solid-light.svg" />
    <link rel="manifest" href="manifest.json" />
    <script src="https://kit.fontawesome.com/b2e4954604.js" crossorigin="anonymous"></script>
    <script>
        if ("serviceWorker" in navigator) {
            window.addEventListener("load", () => {
                navigator.serviceWorker
                    .register("sw.js") // Path to your service worker file
                    .then((registration) => {
                        console.log(
                            "ServiceWorker registration successful with scope: ",
                            registration.scope
                        );
                    })
                    .catch((error) => {
                        console.log("ServiceWorker registration failed: ", error);
                    });
            });
        }
    </script>
</head>

<body>
    <div id="root"></div>

    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jsmediatags@3.9.7/dist/jsmediatags.min.js"></script>

    <script type="text/babel">
        const { useState, useRef, useEffect, useCallback } = React;

        function arrayBufferToBase64(buffer) {
            let binary = '';
            const bytes = new Uint8Array(buffer);
            const len = bytes.byteLength;
            for (let i = 0; i < len; i++) {
                binary += String.fromCharCode(bytes[i]);
            }
            return window.btoa(binary);
        }

        // --- CUSTOM HOOK: useMarquee ---
        const useMarquee = (text, targetRef, gapPixels = 30, speed = 30) => {
            const [isOverflowing, setIsOverflowing] = useState(false);

            useEffect(() => {
                const checkOverflowAndSetMarquee = () => {
                    if (targetRef.current) {
                        const tempSpan = document.createElement("span");
                        tempSpan.style.visibility = "hidden";
                        tempSpan.style.position = "absolute";
                        tempSpan.style.whiteSpace = "nowrap";

                        const computedStyle = getComputedStyle(targetRef.current);
                        tempSpan.style.fontSize = computedStyle.fontSize;
                        tempSpan.style.fontFamily = computedStyle.fontFamily;
                        tempSpan.style.fontWeight = computedStyle.fontWeight;
                        tempSpan.style.letterSpacing = computedStyle.letterSpacing;
                        tempSpan.textContent = text;

                        document.body.appendChild(tempSpan);
                        const singleTextWidth = tempSpan.scrollWidth;
                        document.body.removeChild(tempSpan);

                        const containerWidth = targetRef.current.clientWidth;
                        const overflows = singleTextWidth > containerWidth;

                        setIsOverflowing(overflows);

                        if (overflows) {
                            const distanceToScroll = singleTextWidth + gapPixels;
                            const duration = distanceToScroll / speed;
                            targetRef.current.style.setProperty(
                                "--marquee-duration",
                                `${duration}s`
                            );
                            targetRef.current.style.setProperty(
                                "--marquee-distance",
                                `-${distanceToScroll}px`
                            );
                        } else {
                            targetRef.current.style.setProperty("--marquee-duration", "0s");
                            targetRef.current.style.setProperty(
                                "--marquee-distance",
                                "0px"
                            );
                        }
                    }
                };

                // Debounce or delay the check slightly to ensure layout is stable
                const timeoutId = setTimeout(checkOverflowAndSetMarquee, 100); // Increased delay slightly
                window.addEventListener("resize", checkOverflowAndSetMarquee);

                return () => {
                    clearTimeout(timeoutId);
                    window.removeEventListener("resize", checkOverflowAndSetMarquee);
                };
            }, [text, targetRef, gapPixels, speed]);

            return { isOverflowing };
        };

        const useAudioStateSync = (audioRef, setIsPlaying) => {
            useEffect(() => {
                const audio = audioRef.current;
                if (!audio) return;

                const handlePlay = () => {
                    // console.log("Play event detected by useAudioStateSync");
                    setIsPlaying(true);
                };

                const handlePause = () => {
                    // console.log("Pause event detected by useAudioStateSync");
                    setIsPlaying(false);
                };

                const handleEnded = () => {
                    // console.log("Ended event detected by useAudioStateSync");
                    setIsPlaying(false);
                    // playNextSong will be called by its own event listener on audio element
                };

                audio.addEventListener('play', handlePlay);
                audio.addEventListener('pause', handlePause);
                audio.addEventListener('ended', handleEnded); // Keep this for UI sync if needed

                return () => {
                    audio.removeEventListener('play', handlePlay);
                    audio.removeEventListener('pause', handlePause);
                    audio.removeEventListener('ended', handleEnded);
                };
            }, [audioRef, setIsPlaying]); // setIsPlaying dependency is important
        };
        // --- END CUSTOM HOOK ---

        function App() {
            // Refs
            const audioRef = useRef(null);
            const fileInputRef = useRef(null);
            const currentObjectUrl = useRef(null);
            const sortButtonRef = useRef(null);
            const dropupMenuRef = useRef(null);

            // Web Audio API refs
            const audioContextRef = useRef(null);
            const sourceNodeRef = useRef(null);
            const gainNodeRef = useRef(null);
            const lowShelfFilterRef = useRef(null);
            const peakingFilterRef = useRef(null);
            const highShelfFilterRef = useRef(null);

            // State Variables
            const [playlist, setPlaylist] = useState([]);
            const [currentSongIndex, setCurrentSongIndex] = useState(null);
            const [isPlaying, setIsPlaying] = useState(false);
            // Initialize useAudioStateSync to keep isPlaying in sync with audio element events
            useAudioStateSync(audioRef, setIsPlaying);

            const [isRepeating, setIsRepeating] = useState(false);
            const [isShuffling, setIsShuffling] = useState(false);
            const [isBuffering, setIsBuffering] = useState(false);
            const [albumArtUrl, setAlbumArtUrl] = useState(
                "https://placehold.co/200x200/bec8e4/9baacf?text=No+Art"
            );
            const [songTitle, setSongTitle] = useState(
                "Tidak ada lagu yang sedang diputar"
            );
            const [songArtist, setSongArtist] = useState("");
            const [currentTime, setCurrentTime] = useState(0);
            const [duration, setDuration] = useState(0);
            const [volume, setVolume] = useState(0.8);
            const [isSidebarOpen, setIsSidebarOpen] = useState(false);
            const [isEQSidebarOpen, setIsEQSidebarOpen] = useState(false);
            const [isSortDropupOpen, setIsSortDropupOpen] = useState(false);
            const [isSearchActive, setIsSearchActive] = useState(false);
            const [searchQuery, setSearchQuery] = useState("");

            const titleRef = useRef(null);
            const artistRef = useRef(null);

            const [eqSettings, setEqSettings] = useState({
                low: 0,
                mid: 0,
                high: 0,
            });

            const gapPixels = 30;
            const { isOverflowing: isTitleOverflowing } = useMarquee(songTitle, titleRef, gapPixels);
            const { isOverflowing: isArtistOverflowing } = useMarquee(songArtist, artistRef, gapPixels);

            const filteredPlaylist = playlist.filter((song) =>
                song.name.toLowerCase().includes(searchQuery.toLowerCase())
            );

            useEffect(() => {
                const audio = audioRef.current;
                if (!audio) return;

                const handleWaiting = () => setIsBuffering(true);
                const handlePlaying = () => setIsBuffering(false); // This is also covered by useAudioStateSync's 'play'

                audio.addEventListener('waiting', handleWaiting);
                audio.addEventListener('playing', handlePlaying); // For buffering indicator
                // 'canplay' might also be useful here to set buffering false

                return () => {
                    audio.removeEventListener('waiting', handleWaiting);
                    audio.removeEventListener('playing', handlePlaying);
                };
            }, []); // audioRef is stable, no other deps needed for these specific listeners

            const toggleEQSidebar = () => {
                setIsEQSidebarOpen((prevState) => !prevState);
                setIsSidebarOpen(false);
                if (
                    !isEQSidebarOpen &&
                    audioContextRef.current &&
                    audioContextRef.current.state === "suspended"
                ) {
                    audioContextRef.current
                        .resume()
                        .catch((e) => console.error("Error resuming AudioContext:", e));
                }
            };

            const handleEQChange = useCallback((band, value) => {
                setEqSettings((prevSettings) => ({
                    ...prevSettings,
                    [band]: parseFloat(value),
                }));
            }, []);

            useEffect(() => {
                const audio = audioRef.current;
                if (!audio) return;

                if (!audioContextRef.current) {
                    audioContextRef.current = new (window.AudioContext ||
                        window.webkitAudioContext)();
                }
                const audioContext = audioContextRef.current;

                if (!sourceNodeRef.current) {
                    try {
                        sourceNodeRef.current =
                            audioContext.createMediaElementSource(audio);
                    } catch (e) {
                        console.error("Error creating MediaElementSource. Audio might not be loaded or element is detached.", e);
                        return; // Stop if source cannot be created
                    }
                }

                if (!gainNodeRef.current) {
                    gainNodeRef.current = audioContext.createGain();
                    gainNodeRef.current.gain.value = volume;
                }

                if (!lowShelfFilterRef.current) {
                    lowShelfFilterRef.current = audioContext.createBiquadFilter();
                    lowShelfFilterRef.current.type = "lowshelf";
                    lowShelfFilterRef.current.frequency.value = 250;
                    lowShelfFilterRef.current.Q.value = 1;
                }

                if (!peakingFilterRef.current) {
                    peakingFilterRef.current = audioContext.createBiquadFilter();
                    peakingFilterRef.current.type = "peaking";
                    peakingFilterRef.current.frequency.value = 1500;
                    peakingFilterRef.current.Q.value = 1;
                }

                if (!highShelfFilterRef.current) {
                    highShelfFilterRef.current = audioContext.createBiquadFilter();
                    highShelfFilterRef.current.type = "highshelf";
                    highShelfFilterRef.current.frequency.value = 4000;
                    highShelfFilterRef.current.Q.value = 1;
                }

                // Ensure nodes are connected
                // It's safer to disconnect all and reconnect to avoid multiple connections if this effect re-runs,
                // though with an empty dependency array, it should run once.
                sourceNodeRef.current.disconnect();
                gainNodeRef.current.disconnect();
                lowShelfFilterRef.current.disconnect();
                peakingFilterRef.current.disconnect();
                // highShelfFilterRef.current is the last in our chain before destination, so it doesn't disconnect from others.

                try {
                    sourceNodeRef.current.connect(gainNodeRef.current);
                    gainNodeRef.current.connect(lowShelfFilterRef.current);
                    lowShelfFilterRef.current.connect(peakingFilterRef.current);
                    peakingFilterRef.current.connect(highShelfFilterRef.current);
                    highShelfFilterRef.current.connect(audioContext.destination);
                } catch (e) {
                    console.error("Error connecting audio nodes:", e);
                }


                return () => {
                    // Consider if context should be closed on App unmount
                    // For now, let it persist as nodes are also persisted.
                    // if (audioContextRef.current && audioContextRef.current.state !== "closed") {
                    //     audioContextRef.current.close().catch(e => console.error("Error closing audio context", e));
                    // }
                };
            }, []); // Runs once on mount

            useEffect(() => {
                if (
                    !lowShelfFilterRef.current ||
                    !peakingFilterRef.current ||
                    !highShelfFilterRef.current
                )
                    return;

                lowShelfFilterRef.current.gain.value = eqSettings.low;
                peakingFilterRef.current.gain.value = eqSettings.mid;
                highShelfFilterRef.current.gain.value = eqSettings.high;
            }, [eqSettings]);

            useEffect(() => {
                if (gainNodeRef.current) {
                    gainNodeRef.current.gain.value = volume;
                }
            }, [volume]);

            const handleSearchClick = () => {
                setIsSearchActive((prev) => !prev);
                if (isSearchActive) {
                    setSearchQuery("");
                }
            };

            const toggleSortDropup = () => {
                setIsSortDropupOpen((prev) => !prev);
            };

            const sortPlayListBy = (criteria) => {
                setPlaylist((prevPlaylist) => {
                    const newPlaylist = [...prevPlaylist];
                    newPlaylist.sort((a, b) => {
                        let valA, valB;
                        if (criteria === "title") {
                            valA = (a.name || "").toLowerCase();
                            valB = (b.name || "").toLowerCase();
                        } else if (criteria === "artist") {
                            valA = (a.metadata?.artist || a.name || "").toLowerCase();
                            valB = (b.metadata?.artist || b.name || "").toLowerCase();
                        } else if (criteria === "dateAdded") {
                            valA = a.lastModified;
                            valB = b.lastModified;
                        }
                        if (valA < valB) return -1;
                        if (valA > valB) return 1;
                        return 0;
                    });
                    return newPlaylist;
                });
                setIsSortDropupOpen(false);
            };

            useEffect(() => {
                const handleClickOutside = (event) => {
                    if (isSortDropupOpen && dropupMenuRef.current && !dropupMenuRef.current.contains(event.target) && sortButtonRef.current && !sortButtonRef.current.contains(event.target)) {
                        setIsSortDropupOpen(false);
                    }
                };
                const positionDropupMenu = () => {
                    if (isSortDropupOpen && sortButtonRef.current && dropupMenuRef.current) {
                        const buttonRect = sortButtonRef.current.getBoundingClientRect();
                        const menuElement = dropupMenuRef.current;
                        menuElement.style.top = `${buttonRect.top - menuElement.offsetHeight - 10}px`;
                        menuElement.style.left = `${buttonRect.left}px`;
                        menuElement.style.minWidth = `${buttonRect.width}px`;
                    }
                };
                if (isSortDropupOpen) {
                    document.addEventListener("mousedown", handleClickOutside);
                    window.addEventListener("resize", positionDropupMenu);
                    window.addEventListener("scroll", positionDropupMenu);
                    setTimeout(positionDropupMenu, 0);
                }
                return () => {
                    document.removeEventListener("mousedown", handleClickOutside);
                    window.removeEventListener("resize", positionDropupMenu);
                    window.removeEventListener("scroll", positionDropupMenu);
                };
            }, [isSortDropupOpen]);

            const handleSearchChange = (e) => {
                setSearchQuery(e.target.value);
            };

            const shuffleArray = (array) => {
                let currentIndex = array.length, randomIndex;
                while (currentIndex !== 0) {
                    randomIndex = Math.floor(Math.random() * currentIndex);
                    currentIndex--;
                    [array[currentIndex], array[randomIndex]] = [
                        array[randomIndex],
                        array[currentIndex],
                    ];
                }
                return array;
            };

            const toggleRepeat = () => {
                setIsRepeating((prevRepeating) => {
                    const newRepeatingState = !prevRepeating;
                    if (newRepeatingState) setIsShuffling(false); // Turn off shuffle if repeat is turned on
                    if (audioRef.current) audioRef.current.loop = newRepeatingState; // Directly set loop on audio element
                    return newRepeatingState;
                });
            };

            const toggleShuffle = () => {
                setIsShuffling((prevShuffling) => {
                    const newShufflingState = !prevShuffling;
                    if (newShufflingState) {
                        setIsRepeating(false); // Turn off repeat if shuffle is turned on
                        if (audioRef.current) audioRef.current.loop = false;
                        // Re-shuffle playlist when shuffle is activated
                        setPlaylist((oldPlaylist) => {
                            const currentSong = currentSongIndex !== null ? oldPlaylist[currentSongIndex] : null;
                            const shuffled = shuffleArray([...oldPlaylist.filter(song => song !== currentSong)]);
                            const newPlaylist = currentSong ? [currentSong, ...shuffled] : shuffled;
                            // Find the new index of the current song (it should be 0 if it was playing)
                            if (currentSong) {
                                const newIdx = newPlaylist.findIndex(s => s === currentSong);
                                setCurrentSongIndex(newIdx); // Update index to reflect new position
                            } else if (newPlaylist.length > 0) {
                                setCurrentSongIndex(0); // If no song was current, start with the first of shuffled
                            }
                            return newPlaylist;
                        });
                    }
                    // If turning shuffle OFF, you might want to revert to original order or sort
                    // For now, it just keeps the current shuffled order.
                    return newShufflingState;
                });
            };

            const playNextSong = useCallback(() => {
                if (playlist.length === 0) return;
                const audio = audioRef.current;
                if (!audio) return;

                // If repeating the current song, handled by audio.loop, so this function effectively skips
                // unless audio.loop is false. The 'ended' event will fire if loop is false.
                if (audio.loop) { // if native loop is true (isRepeating is true)
                    // audio will loop automatically. If we want to manually restart:
                    // audio.currentTime = 0;
                    // audio.play().catch(e => console.error("Error re-playing looped song:", e));
                    return;
                }

                let nextIndex;
                if (isShuffling) {
                    if (playlist.length <= 1) {
                        nextIndex = 0;
                    } else {
                        // Simple shuffle: pick any random song that is not the current one
                        // More robust shuffle might involve a shuffled queue
                        do {
                            nextIndex = Math.floor(Math.random() * playlist.length);
                        } while (playlist.length > 1 && nextIndex === currentSongIndex);
                    }
                } else {
                    nextIndex = (currentSongIndex + 1) % playlist.length;
                }
                setCurrentSongIndex(nextIndex);
                setIsPlaying(true); // Let the useEffect for currentSongIndex change handle playing if appropriate
            }, [playlist, currentSongIndex, isShuffling, isRepeating]); // isRepeating to know if audio.loop is set

            useEffect(() => {
                const audio = audioRef.current;
                if (!audio) return;

                const handleTimeUpdate = () => setCurrentTime(audio.currentTime);
                const handleLoadedMetadata = () => setDuration(audio.duration);
                const handleAudioEnded = () => { // Renamed to avoid conflict
                    // This is called when a song finishes naturally (and audio.loop is false)
                    // console.log("Audio ended event triggered playNextSong");
                    if (!isRepeating) { // if not repeating single song via audio.loop
                        playNextSong();
                    } else { // if isRepeating is true, audio.loop should handle it.
                        // If audio.loop was false but isRepeating true, this would play next.
                        // But toggleRepeat now sets audio.loop.
                    }
                };
                const handleError = (error) => {
                    console.error("Audio playback error:", error);
                    setIsPlaying(false); // Update UI
                    // Optionally, try to play next song or show error to user
                };

                audio.addEventListener('timeupdate', handleTimeUpdate);
                audio.addEventListener('loadedmetadata', handleLoadedMetadata);
                audio.addEventListener('ended', handleAudioEnded);
                audio.addEventListener('error', handleError);

                return () => {
                    audio.removeEventListener('timeupdate', handleTimeUpdate);
                    audio.removeEventListener('loadedmetadata', handleLoadedMetadata);
                    audio.removeEventListener('ended', handleAudioEnded);
                    audio.removeEventListener('error', handleError);
                };
            }, [playNextSong, isRepeating]); // playNextSong and isRepeating are dependencies for ended logic


            // *** MODIFIED useEffect for loading song when currentSongIndex changes ***
            useEffect(() => {
                const audio = audioRef.current;
                if (!audio) return;

                if (currentObjectUrl.current) {
                    URL.revokeObjectURL(currentObjectUrl.current);
                    currentObjectUrl.current = null;
                }

                if (currentSongIndex !== null && playlist[currentSongIndex]) {
                    const song = playlist[currentSongIndex];
                    const newObjectUrl = URL.createObjectURL(song);
                    currentObjectUrl.current = newObjectUrl;

                    // IMPORTANT: Setting audio.src resets currentTime.
                    // This is desired when changing songs.
                    audio.src = newObjectUrl;
                    audio.loop = isRepeating; // Ensure loop state is set for the new song

                    jsmediatags.read(song, {
                        onSuccess: function (tag) {
                            const title = tag.tags.title || song.name.split('.').slice(0, -1).join('.') || song.name;
                            const artist = tag.tags.artist || '';
                            setSongTitle(title);
                            setSongArtist(artist);
                            if (tag.tags.picture) {
                                const base64String = arrayBufferToBase64(tag.tags.picture.data);
                                const imageUrl = `data:${tag.tags.picture.format};base64,${base64String}`;
                                setAlbumArtUrl(imageUrl);
                            } else {
                                setAlbumArtUrl("https://placehold.co/200x200/bec8e4/9baacf?text=No+Art");
                            }
                        },
                        onError: function (error) {
                            console.error("Error reading media tags:", error);
                            setSongTitle(song.name.split('.').slice(0, -1).join('.') || song.name);
                            setSongArtist("");
                            setAlbumArtUrl("https://placehold.co/200x200/bec8e4/9baacf?text=No+Art");
                        }
                    });

                    const handleCanPlay = () => {
                        // When a new song is loaded and ready
                        setDuration(audio.duration); // Update duration immediately
                        if (isPlaying) { // If the player was in a "playing" state before song change
                            audio.play().catch(error => {
                                console.error("Autoplay prevented on new song load:", error);
                                setIsPlaying(false); // Correct state if autoplay fails
                            });
                        }
                        // No need to remove listener here if it's added outside, or ensure it's specific
                    };

                    // audio.load() is implicitly called when src changes or can be explicit.
                    // It's good practice to call it to ensure the browser fetches the media.
                    audio.load();

                    // Add event listener for when the new audio can play
                    // Use { once: true } if you only want it to fire once per src change.
                    audio.addEventListener('canplay', handleCanPlay, { once: true });


                    // Cleanup for this specific src load
                    return () => {
                        audio.removeEventListener('canplay', handleCanPlay);
                        // If the song is changing, we might want to pause the outgoing audio
                        if (audio && !audio.paused) {
                            // audio.pause(); // This might be too aggressive if not desired.
                        }
                    };

                } else { // No song selected or playlist empty
                    audio.src = "";
                    setIsPlaying(false);
                    setSongTitle("Tidak ada lagu yang sedang diputar");
                    setSongArtist("");
                    setAlbumArtUrl("https://placehold.co/200x200/bec8e4/9baacf?text=No+Art");
                    setCurrentTime(0);
                    setDuration(0);
                }
                // KEY CHANGE: Removed `isPlaying` from dependencies.
                // This effect now only runs when the song itself changes.
                // isRepeating is added because audio.loop needs to be set when src changes.
            }, [currentSongIndex, playlist, isRepeating]);


            // *** useEffect for handling play/pause commands based on isPlaying state ***
            useEffect(() => {
                const audio = audioRef.current;
                if (!audio || !audio.src || currentSongIndex === null) {
                    // If isPlaying is true but no song is ready, set isPlaying to false.
                    if (isPlaying) setIsPlaying(false);
                    return;
                }

                if (audioContextRef.current && audioContextRef.current.state === "suspended") {
                    audioContextRef.current.resume().catch(e => console.error("Error resuming AudioContext:", e));
                }

                if (isPlaying) {
                    // Check if audio is actually paused before playing
                    // This avoids issues if 'play' event already fired and set isPlaying
                    if (audio.paused) {
                        audio.play().catch(error => {
                            console.error("Error in isPlaying useEffect (play):", error);
                            // If play fails (e.g., user hasn't interacted, or other reasons)
                            // Set isPlaying to false to reflect the actual state.
                            setIsPlaying(false);
                        });
                    }
                } else {
                    // Check if audio is not paused before pausing
                    if (!audio.paused) {
                        audio.pause();
                    }
                }
                // This effect reacts to isPlaying state changes or when currentSongIndex makes a song available/unavailable.
                // audioRef itself doesn't change, so it's not strictly needed as a dep if stable.
            }, [isPlaying, currentSongIndex, audioRef]);


            const handleFileChange = (event) => {
                const files = Array.from(event.target.files);
                const audioFiles = files.filter(
                    (file) =>
                        file.type.startsWith("audio/") ||
                        /\.(mp3|wav|ogg|flac)$/i.test(file.name)
                );

                if (audioFiles.length > 0) {
                    const newPlaylist = isShuffling ? shuffleArray(audioFiles) : audioFiles;
                    setPlaylist(newPlaylist);
                    // If no song was playing or playlist was empty, select the first song.
                    // If a song was already playing, changing the playlist might require
                    // more nuanced handling of currentSongIndex (e.g., try to find the same song or reset).
                    // For simplicity, if currentSongIndex is invalid for new playlist, reset.
                    if (currentSongIndex === null || currentSongIndex >= newPlaylist.length) {
                        setCurrentSongIndex(0);
                    }
                    // If files are added, and player was paused, it should remain paused.
                    // If player was playing, it should attempt to play the new currentSongIndex[0] (due to above).
                } else {
                    // No valid audio files selected
                    // Optionally clear playlist or show a message
                }
                if (fileInputRef.current) { // Reset file input for re-selection of same folder
                    fileInputRef.current.value = "";
                }
            };

            const openFolder = () => fileInputRef.current.click();

            const openSingleFile = () => {
                const input = document.createElement("input");
                input.type = "file";
                input.accept = "audio/*, .mp3, .wav, .ogg, .flac";
                input.onchange = (event) => {
                    const file = event.target.files[0];
                    if (file) {
                        setPlaylist((prevPlaylist) => {
                            // Add new file and then re-apply shuffle if active
                            let updatedPlaylist = [...prevPlaylist, file];
                            if (isShuffling) {
                                // If shuffling, new file could go anywhere, or re-shuffle all but current
                                // For simplicity, just add and then re-shuffle the part after current song
                                const currentSong = currentSongIndex !== null ? updatedPlaylist[currentSongIndex] : null;
                                let filesToShuffle = currentSong ? updatedPlaylist.filter(s => s !== currentSong) : [...updatedPlaylist];
                                filesToShuffle = shuffleArray(filesToShuffle);
                                updatedPlaylist = currentSong ? [currentSong, ...filesToShuffle] : filesToShuffle;
                            }

                            if (currentSongIndex === null && updatedPlaylist.length > 0) {
                                setCurrentSongIndex(0); // Select the first song if none was selected
                            } else if (currentSongIndex !== null && isShuffling) {
                                // Update currentSongIndex to its new position after shuffle
                                const currentActualSong = prevPlaylist[currentSongIndex];
                                const newIdx = updatedPlaylist.findIndex(s => s === currentActualSong);
                                if (newIdx !== -1) setCurrentSongIndex(newIdx);
                                else if (updatedPlaylist.length > 0) setCurrentSongIndex(0); // Fallback
                            }
                            return updatedPlaylist;
                        });
                    }
                };
                input.click();
            };

            const togglePlayPause = useCallback(() => {
                if (playlist.length === 0 || currentSongIndex === null) return;

                const audio = audioRef.current;
                if (!audio || !audio.src) { // Check if src is set
                    console.warn("togglePlayPause: No audio source loaded.");
                    return;
                }

                if (audioContextRef.current?.state === "suspended") {
                    audioContextRef.current.resume().catch(console.error);
                }

                // Directly toggle the isPlaying state.
                // The useEffect hook listening to isPlaying will handle audio.play/pause.
                setIsPlaying(prevIsPlaying => !prevIsPlaying);

            }, [playlist, currentSongIndex]); // Dependencies ensure it can act on a loaded song.

            const playSong = (indexInFiltered) => {
                const actualIndex = playlist.indexOf(
                    filteredPlaylist[indexInFiltered]
                );
                if (actualIndex === -1) return;

                if (audioContextRef.current?.state === "suspended") {
                    audioContextRef.current.resume().catch(e => console.error("Error resuming AudioContext:", e));
                }

                if (actualIndex !== currentSongIndex) {
                    setCurrentSongIndex(actualIndex);
                    setIsPlaying(true); // Intend to play the new song
                } else {
                    // If clicking the currently selected song, toggle play/pause
                    togglePlayPause();
                }
            };

            const playPreviousSong = () => {
                if (playlist.length === 0) return;
                let prevIndex;
                if (isShuffling) {
                    if (playlist.length <= 1) {
                        prevIndex = 0;
                    } else {
                        do {
                            prevIndex = Math.floor(Math.random() * playlist.length);
                        } while (playlist.length > 1 && prevIndex === currentSongIndex);
                    }
                } else {
                    prevIndex = (currentSongIndex - 1 + playlist.length) % playlist.length;
                }
                setCurrentSongIndex(prevIndex);
                setIsPlaying(true); // Intend to play previous song
            };

            const handleProgressBarChange = (e) => {
                const audio = audioRef.current;
                if (!audio || isNaN(audio.duration)) return; // Check for NaN duration

                const newTime = parseFloat(e.target.value);
                // setCurrentTime(newTime); // Optional: for immediate slider UI update, but timeupdate handles it
                audio.currentTime = newTime;
            };

            const handleVolumeChange = (e) => {
                const newVolume = parseFloat(e.target.value);
                setVolume(newVolume);
                // Web Audio API's gainNode handles actual volume via useEffect
            };

            const formatTime = (seconds) => {
                if (isNaN(seconds) || seconds < 0) return "0:00";
                const minutes = Math.floor(seconds / 60);
                const remainingSeconds = Math.floor(seconds % 60);
                return `${minutes}:${remainingSeconds < 10 ? "0" : ""}${remainingSeconds}`;
            };

            const toggleSidebar = () => {
                setIsSidebarOpen((prevState) => !prevState);
                setIsEQSidebarOpen(false);
            };
            const handleCloseBothSidebars = () => {
                setIsSidebarOpen(false);
                setIsEQSidebarOpen(false);
            };

            const handleDeleteSong = (indexToDeleteInOriginal, event) => {
                event.stopPropagation();
                setPlaylist((prevPlaylist) => {
                    const songToDelete = prevPlaylist[indexToDeleteInOriginal];
                    const newPlaylist = prevPlaylist.filter((_, idx) => idx !== indexToDeleteInOriginal);

                    if (newPlaylist.length === 0) {
                        setCurrentSongIndex(null);
                        setIsPlaying(false); // Stop playing if playlist is empty
                        // audioRef.current.src = ""; // Already handled by song loading useEffect
                    } else if (currentSongIndex === indexToDeleteInOriginal) {
                        // If the deleted song was the current one
                        // Option 1: Play next (or 0 if it was the last)
                        // Option 2: Just select next/0 but don't auto-play (let user decide)
                        // For now, select next/0 and maintain isPlaying state
                        setCurrentSongIndex(indexToDeleteInOriginal % newPlaylist.length);
                        // If it was playing, the song loading effect will try to play the new current song.
                    } else if (currentSongIndex > indexToDeleteInOriginal) {
                        setCurrentSongIndex(currentSongIndex - 1); // Adjust index
                    }
                    // If currentSongIndex < indexToDeleteInOriginal, no change to index needed.
                    return newPlaylist;
                });
            };

            const clearPlayList = () => {
                // audioRef.current handled by useEffect when currentSongIndex becomes null
                setPlaylist([]);
                setCurrentSongIndex(null); // This will trigger the song loading useEffect to clear src etc.
                // setIsPlaying(false); // Also handled by useEffect
                setSearchQuery("");
                setIsRepeating(false);
                setIsShuffling(false);
                if (audioRef.current) audioRef.current.loop = false;
                if (fileInputRef.current) {
                    fileInputRef.current.value = "";
                }
                setEqSettings({ low: 0, mid: 0, high: 0 });
            };

            return (
                <div className="container">
                    {/* Combined Sidebar Card */}
                    <div
                        className={`playlist-card ${isSidebarOpen || isEQSidebarOpen ? "open" : "collapsed"
                            }`}
                    >
                        <div className="playlist-header">
                            {/* Display header based on which sidebar is open, or default to Playlist if neither is explicitly open but the main sidebar is expanded */}
                            {isSidebarOpen && <h3>Playlist</h3>}
                            {isEQSidebarOpen && <h3>Equalizer</h3>}

                            <div className="header-buttons-group">
                                {/* Show search button only if playlist sidebar is open */}
                                {isSidebarOpen && (
                                    <button
                                        className="search-toggle-btn"
                                        onClick={handleSearchClick}
                                        aria-label="Search Playlist"
                                    >
                                        <i className="fas fa-search"></i>
                                    </button>
                                )}
                                {/* Toggle button for the main playlist sidebar */}
                                <button
                                    className="sidebar-toggle-btn"
                                    onClick={
                                        isSidebarOpen || isEQSidebarOpen
                                            ? handleCloseBothSidebars // If either is open, this button closes both
                                            : toggleSidebar // Otherwise, it opens the playlist sidebar
                                    }
                                    aria-label={
                                        isSidebarOpen || isEQSidebarOpen
                                            ? "Close Sidebars" // Label for closing both
                                            : "Open Playlist" // Label for opening playlist
                                    }
                                >
                                    <i
                                        className={`fas ${isSidebarOpen || isEQSidebarOpen
                                            ? "fa-times"
                                            : "fa-bars"
                                            }`}
                                    ></i>
                                </button>
                            </div>
                        </div>

                        {/* Toggle button for the equalizer sidebar, visible when the main sidebar is open (to switch to EQ) or when both are collapsed (to open EQ) */}
                        {!isSidebarOpen && !isEQSidebarOpen && (
                            <button
                                className={`sidebar-toggle-btn mt-3 ${isEQSidebarOpen ? "eq-button-hidden" : ""
                                    }`}
                                aria-label="Open Equalizer"
                                onClick={toggleEQSidebar}
                            >
                                <i className="fas fa-sliders" aria-hidden="true"></i>
                            </button>
                        )}

                        {/* Content for Playlist */}
                        {isSidebarOpen && !isEQSidebarOpen && (
                            <>
                                {isSearchActive && (
                                    <div className="search-input-container">
                                        <input
                                            type="text"
                                            placeholder="Cari lagu..."
                                            value={searchQuery}
                                            onChange={handleSearchChange}
                                            className="search-input"
                                        />
                                    </div>
                                )}
                                <ul className="playlist-list">
                                    {filteredPlaylist.length === 0 && searchQuery !== "" ? (
                                        <li className="playlist-empty">
                                            No matching songs found.
                                        </li>
                                    ) : filteredPlaylist.length === 0 &&
                                        playlist.length > 0 &&
                                        searchQuery === "" ? (
                                        <li className="playlist-empty">
                                            Belum ada lagu yang ditambahkan.
                                        </li>
                                    ) : playlist.length === 0 ? (
                                        <li className="playlist-empty">
                                            Belum ada lagu yang ditambahkan.
                                        </li>
                                    ) : (
                                        filteredPlaylist.map((song, index) => (
                                            <li
                                                key={song.name + index + playlist.indexOf(song)}
                                                className={`playlist-item ${song === playlist[currentSongIndex] ? "active" : ""
                                                    }`}
                                            >
                                                <div
                                                    className="playlist-item-inner"
                                                    onClick={() => playSong(index)}
                                                >
                                                    <span className="playlist-song-name">
                                                        {song.name.split(".").slice(0, -1).join(".") ||
                                                            song.name}
                                                    </span>
                                                    <button
                                                        className="btn btn__delete"
                                                        onClick={(e) =>
                                                            handleDeleteSong(playlist.indexOf(song), e)
                                                        }
                                                        aria-label={`Delete ${song.name}`}
                                                    >
                                                        <i className="fas fa-trash-alt"></i>
                                                    </button>
                                                </div>
                                            </li>
                                        ))
                                    )}
                                </ul>
                                <div
                                    className="button-container-flex"
                                    style={{ marginTop: "auto", paddingTop: "1.5rem" }}
                                >
                                    <button
                                        className="btn btn-pl btn__secondary"
                                        onClick={openFolder}
                                        title="Buka Folder"
                                    >
                                        <i className="fas fa-folder"></i>
                                    </button>
                                    <button
                                        className="btn btn-pl btn__secondary"
                                        onClick={openSingleFile}
                                        title="Tambahkan File ke Playlist"
                                    >
                                        <i className="fas fa-file-audio"></i>
                                    </button>
                                    <button
                                        className="btn btn-pl btn__secondary"
                                        onClick={clearPlayList}
                                        title="Bersihkan Playlist"
                                    >
                                        <i className="fas fa-trash"></i>
                                    </button>
                                    <div className="dropup-container-absolute">
                                        <div className="dropup">
                                            <button
                                                className="btn btn-pl btn__secondary dropup-toggle"
                                                onClick={toggleSortDropup}
                                                title="Urutkan Playlist berdasarkan..."
                                                ref={sortButtonRef}
                                            >
                                                <i className="fa-solid fa-sort"></i>
                                            </button>
                                            {isSortDropupOpen && (
                                                <div
                                                    className="dropup-menu"
                                                    ref={dropupMenuRef}
                                                    style={{ position: "fixed", zIndex: 1000 }}
                                                >
                                                    <button
                                                        className="dropup-item"
                                                        onClick={() => sortPlayListBy("title")}
                                                    >
                                                        Judul
                                                    </button>
                                                    <button
                                                        className="dropup-item"
                                                        onClick={() => sortPlayListBy("artist")}
                                                    >
                                                        Artist
                                                    </button>
                                                    <button
                                                        className="dropup-item"
                                                        onClick={() => sortPlayListBy("dateAdded")}
                                                    >
                                                        Tanggal
                                                    </button>
                                                </div>
                                            )}
                                        </div>
                                    </div>
                                    <button
                                        className="btn btn-pl btn__secondary"
                                        title="Pengaturan"
                                    >
                                        <i className="fa-solid fa-gear"></i>
                                    </button>
                                </div>
                            </>
                        )}

                        {/* Content for Equalizer */}
                        {isEQSidebarOpen && !isSidebarOpen && (
                            <div className="eq-controls">
                                <div className="eq-band">
                                    <label>Bass</label>
                                    <input
                                        type="range"
                                        min="-12"
                                        max="12"
                                        value={eqSettings.low} // Changed from bass to low
                                        onChange={(e) => handleEQChange("low", e.target.value)} // Using handleEQChange
                                        className="eq-slider"
                                    />
                                    <span>{eqSettings.low}dB</span>{" "}
                                    {/* Changed from bass to low */}
                                </div>
                                <div className="eq-band">
                                    <label>Mid</label>
                                    <input
                                        type="range"
                                        min="-12"
                                        max="12"
                                        value={eqSettings.mid}
                                        onChange={(e) => handleEQChange("mid", e.target.value)}
                                        className="eq-slider"
                                    />
                                    <span>{eqSettings.mid}dB</span>
                                </div>
                                <div className="eq-band">
                                    <label>Treble</label>
                                    <input
                                        type="range"
                                        min="-12"
                                        max="12"
                                        value={eqSettings.high} // Changed from treble to high
                                        onChange={(e) => handleEQChange("high", e.target.value)} // Using handleEQChange
                                        className="eq-slider"
                                    />
                                    <span>{eqSettings.high}dB</span>{" "}
                                    {/* Changed from treble to high */}
                                </div>
                                <button
                                    className="btn btn-pl btn__secondary"
                                    onClick={() => setEqSettings({ low: 0, mid: 0, high: 0 })} // Changed bass/treble to low/high
                                    style={{ marginTop: "1rem" }}
                                >
                                    Reset EQ
                                </button>
                            </div>
                        )}

                        {/* Logo for collapsed state - always rendered, CSS controls visibility */}
                        {!isSidebarOpen && !isEQSidebarOpen && (
                            <div className="playlist-card-logo mb-3 font-weight-bold">
                                Kyrop
                                <i className="fas fa-compact-disc"></i>d{" "}
                                {/* Example logo icon */}
                            </div>
                        )}

                        {/* File input (always present but hidden) */}
                        <input
                            type="file"
                            webkitdirectory=""
                            directory=""
                            multiple=""
                            ref={fileInputRef}
                            onChange={handleFileChange}
                            style={{ display: "none" }}
                            accept="audio/*,.mp3,.wav,.ogg,.flac"
                        />
                    </div>

                    {/* Main Player Card */}
                    <div className="player-card">
                        <div className="album-art-wrapper">
                            <img
                                src={albumArtUrl}
                                alt="Album Art"
                                className="album-art"
                                onError={(e) => {
                                    e.target.onerror = null;
                                    e.target.src =
                                        "https://placehold.co/200x200/bec8e4/9baacf?text=No+Art";
                                }}
                            />
                        </div>
                        <div className="song-info">
                            <h2
                                className={`song-title ${isTitleOverflowing ? "is-scrolling" : ""
                                    }`}
                                ref={titleRef}
                                title={songTitle}
                            >
                                <span>
                                    {songTitle}
                                    {isTitleOverflowing && (
                                        <>
                                            <span
                                                className="inline-block"
                                                style={{
                                                    width: `${gapPixels}px`,
                                                    display: "inline-block",
                                                }}
                                            ></span>
                                            {songTitle}
                                        </>
                                    )}
                                </span>
                            </h2>
                            <p
                                className={`song-artist ${isArtistOverflowing ? "is-scrolling-artist" : ""
                                    }`}
                                ref={artistRef}
                                title={songArtist}
                            >
                                <span>
                                    {songArtist}
                                    {isArtistOverflowing && (
                                        <>
                                            <span
                                                className="inline-block"
                                                style={{
                                                    width: `${gapPixels}px`,
                                                    display: "inline-block",
                                                }}
                                            ></span>
                                            {songArtist}
                                        </>
                                    )}
                                </span>
                            </p>
                        </div>

                        <div className="controls-wrapper">
                            <div className="slider"> {/* This is your main container, replacing .progress-bar-container */}
                                <div className="slider__box">
                                    {/* The hidden functional input range */}
                                    <input
                                        type="range"
                                        min="0"
                                        max={duration || 0}
                                        value={currentTime}
                                        onChange={handleProgressBarChange}
                                        className="progress-slider" /* Keep this class for the functional input */
                                        disabled={playlist.length === 0}
                                    />
                                    {/* These are the custom visual elements, styled to look like the reference */}
                                    <span className="slider__btn" /* This is your custom thumb */
                                        style={{ left: `${(currentTime / duration) * 100 || 0}%` }}>
                                    </span>
                                    <span className="slider__color" /* This is your progress fill */
                                        style={{ width: `${((currentTime / duration) * 100 || 0) + 1}%` }}>
                                    </span>
                                    <span className="slider__tooltip" /* This is your tooltip */
                                        style={{ left: `${(currentTime / duration) * 100 || 0}%` }}>
                                        {formatTime(currentTime)}
                                    </span>
                                </div>

                                {/* The time display remains outside the slider__box, aligned with your original structure */}
                                <div className="time-display">
                                    <span>{formatTime(currentTime)}</span>
                                    <span>{formatTime(duration)}</span>
                                </div>
                            </div>

                            <div className="player-buttons">
                                <button
                                    className={`icon__repeat ${isRepeating ? "active" : ""}`}
                                    onClick={toggleRepeat} // MODIFIED: Uses updated toggleRepeat
                                    aria-label="Repeat Song"
                                    disabled={playlist.length === 0}
                                >
                                    <i className="fas fa-redo"></i>
                                </button>
                                <button
                                    className="icon__prev"
                                    onClick={playPreviousSong}
                                    aria-label="Previous Song"
                                    disabled={playlist.length === 0}
                                >
                                    <i className="fas fa-step-backward"></i>
                                </button>
                                <div className="circle">
                                    <button
                                        className={`circle__btn ${isPlaying ? "shadow" : ""}`}
                                        onClick={togglePlayPause}
                                        aria-label={isPlaying ? "Pause" : "Play"}
                                        disabled={playlist.length === 0}
                                    >
                                        <i className="fas fa-play"></i>
                                        <i className="fas fa-pause"></i>
                                    </button>
                                    <div
                                        className={`circle__back-1 ${isPlaying && playlist.length > 0 ? "" : "paused"
                                            }`}
                                    ></div>
                                    <div
                                        className={`circle__back-2 ${isPlaying && playlist.length > 0 ? "" : "paused"
                                            }`}
                                    ></div>
                                </div>
                                <button
                                    className="icon__next"
                                    onClick={playNextSong}
                                    aria-label="Next Song"
                                    disabled={playlist.length === 0}
                                >
                                    <i className="fas fa-step-forward"></i>
                                </button>
                                <button
                                    className={`icon__shuffle ${isShuffling ? "active" : ""}`}
                                    onClick={toggleShuffle} // MODIFIED: Uses updated toggleShuffle
                                    aria-label="Shuffle Playlist"
                                    disabled={playlist.length === 0}
                                >
                                    <i className="fas fa-random"></i>
                                </button>
                            </div>

                            <div className="volume-control">
                                <i className="fas fa-volume-down"></i>
                                <input
                                    type="range"
                                    min="0"
                                    max="1"
                                    step="0.01"
                                    value={volume}
                                    onChange={handleVolumeChange}
                                    className="volume-slider"
                                    aria-label="Volume Slider"
                                    disabled={playlist.length === 0}
                                />
                                <i className="fas fa-volume-up"></i>
                            </div>
                        </div>
                    </div>
                    <audio ref={audioRef} preload="metadata"></audio>
                </div>
            );
        }

        ReactDOM.render(<App />, document.getElementById("root"));
    </script>
</body>

</html>