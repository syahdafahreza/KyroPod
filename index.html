<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>KyroPod | By Syahda Fahreza</title>
    <link rel="stylesheet" href="themes/neuromorphic.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css" />
    <link href="fontawesome/css/fontawesome.css" rel="stylesheet" />
    <link href="fontawesome/css/brands.css" rel="stylesheet" />
    <link href="fontawesome/css/solid.css" rel="stylesheet" />
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700&display=swap" rel="stylesheet" />
    <link rel="icon" type="image/svg+xml" href="svg/compact-disc-solid-light.svg"
        media="(prefers-color-scheme: dark)" />
    <link rel="icon" type="image/svg+xml" href="svg/compact-disc-solid-dark.svg"
        media="(prefers-color-scheme: light)" />
    <link rel="icon" type="image/svg+xml" href="svg/compact-disc-solid-light.svg" />
    <link rel="manifest" href="manifest.json" />
    <script src="https://kit.fontawesome.com/b2e4954604.js" crossorigin="anonymous"></script>
    <script>
        if ("serviceWorker" in navigator) {
            window.addEventListener("load", () => {
                navigator.serviceWorker
                    .register("sw.js") // Path to your service worker file
                    .then((registration) => {
                        console.log(
                            "ServiceWorker registration successful with scope: ",
                            registration.scope
                        );
                    })
                    .catch((error) => {
                        console.log("ServiceWorker registration failed: ", error);
                    });
            });
        }
    </script>
    <style>
        /* Ensure playlist-list is scrollable and has a defined height or max-height */
        .playlist-list {
            overflow-y: auto;
            /* Example: Adjust this height as needed, or use flexbox to fill available space */
            /* max-height: calc(100vh - 200px); */
            /* Or a fixed height if the card is fixed */
            /* If .playlist-card has a fixed height, and header/footer also have fixed heights: */
            /* max-height: 300px; */
            /* This is an example, adjust to your layout */
            flex-grow: 1;
            /* If the parent of playlist-header, playlist-list, and button-container-flex is a column flex container */
            min-height: 100px;
            /* Ensure it has some height to be scrollable */
        }

        .playlist-card.open .playlist-content-wrapper {
            /* Create a wrapper for flex layout if needed */
            display: flex;
            flex-direction: column;
            height: 100%;
            /* Or a specific height, e.g., calc(100% - HEADER_HEIGHT - FOOTER_HEIGHT) */
            overflow: hidden;
            /* Prevent wrapper from overflowing, let list scroll */
        }
    </style>
</head>

<body>
    <div id="root"></div>

    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jsmediatags@3.9.7/dist/jsmediatags.min.js"></script>

    <script type="text/babel">
        const { useState, useRef, useEffect, useCallback } = React;

        function arrayBufferToBase64(buffer) {
            let binary = '';
            const bytes = new Uint8Array(buffer);
            const len = bytes.byteLength;
            for (let i = 0; i < len; i++) {
                binary += String.fromCharCode(bytes[i]);
            }
            return window.btoa(binary);
        }

        // --- CUSTOM HOOK: useMarquee ---
        const useMarquee = (text, targetRef, gapPixels = 30, speed = 30) => {
            const [isOverflowing, setIsOverflowing] = useState(false);

            useEffect(() => {
                const checkOverflowAndSetMarquee = () => {
                    if (targetRef.current) {
                        const tempSpan = document.createElement("span");
                        tempSpan.style.visibility = "hidden";
                        tempSpan.style.position = "absolute";
                        tempSpan.style.whiteSpace = "nowrap";

                        const computedStyle = getComputedStyle(targetRef.current);
                        tempSpan.style.fontSize = computedStyle.fontSize;
                        tempSpan.style.fontFamily = computedStyle.fontFamily;
                        tempSpan.style.fontWeight = computedStyle.fontWeight;
                        tempSpan.style.letterSpacing = computedStyle.letterSpacing;
                        tempSpan.textContent = text;

                        document.body.appendChild(tempSpan);
                        const singleTextWidth = tempSpan.scrollWidth;
                        document.body.removeChild(tempSpan);

                        const containerWidth = targetRef.current.clientWidth;
                        const overflows = singleTextWidth > containerWidth;

                        setIsOverflowing(overflows);

                        if (overflows) {
                            const distanceToScroll = singleTextWidth + gapPixels;
                            const duration = distanceToScroll / speed;
                            targetRef.current.style.setProperty(
                                "--marquee-duration",
                                `${duration}s`
                            );
                            targetRef.current.style.setProperty(
                                "--marquee-distance",
                                `-${distanceToScroll}px`
                            );
                        } else {
                            targetRef.current.style.setProperty("--marquee-duration", "0s");
                            targetRef.current.style.setProperty(
                                "--marquee-distance",
                                "0px"
                            );
                        }
                    }
                };
                const timeoutId = setTimeout(checkOverflowAndSetMarquee, 100);
                window.addEventListener("resize", checkOverflowAndSetMarquee);
                return () => {
                    clearTimeout(timeoutId);
                    window.removeEventListener("resize", checkOverflowAndSetMarquee);
                };
            }, [text, targetRef, gapPixels, speed]);
            return { isOverflowing };
        };

        const useAudioStateSync = (audioRef, setIsPlaying) => {
            useEffect(() => {
                const audio = audioRef.current;
                if (!audio) return;

                const handlePlay = () => setIsPlaying(true);
                const handlePause = () => setIsPlaying(false);

                audio.addEventListener('play', handlePlay);
                audio.addEventListener('pause', handlePause);

                return () => {
                    audio.removeEventListener('play', handlePlay);
                    audio.removeEventListener('pause', handlePause);
                };
            }, [audioRef, setIsPlaying]);
        };
        // --- END CUSTOM HOOK ---

        function App() {
            const audioRef = useRef(null);
            const fileInputRef = useRef(null);
            const currentObjectUrl = useRef(null);
            const sortButtonRef = useRef(null);
            const dropupMenuRef = useRef(null);
            const audioContextRef = useRef(null);
            const sourceNodeRef = useRef(null);
            const gainNodeRef = useRef(null);
            const lowShelfFilterRef = useRef(null);
            const peakingFilterRef = useRef(null);
            const highShelfFilterRef = useRef(null);
            const playlistListRef = useRef(null); // Ref for the playlist UL element

            const [playlist, setPlaylist] = useState([]);
            const [currentSongIndex, setCurrentSongIndex] = useState(null);
            const [isPlaying, setIsPlaying] = useState(false);
            const sliderBoxRef = useRef(null);
            useAudioStateSync(audioRef, setIsPlaying);

            const isPlayingRef = useRef(isPlaying);
            useEffect(() => {
                isPlayingRef.current = isPlaying;
            }, [isPlaying]);

            const [isRepeating, setIsRepeating] = useState(false);
            const [isShuffling, setIsShuffling] = useState(false);
            const [isBuffering, setIsBuffering] = useState(false);
            const [albumArtUrl, setAlbumArtUrl] = useState("https://placehold.co/200x200/bec8e4/9baacf?text=No+Art");
            const [songTitle, setSongTitle] = useState("Tidak ada lagu yang sedang diputar");
            const [songArtist, setSongArtist] = useState("");
            const [currentTime, setCurrentTime] = useState(0);
            const [duration, setDuration] = useState(0);
            const [volume, setVolume] = useState(0.8);
            const [isSidebarOpen, setIsSidebarOpen] = useState(false);
            const [isEQSidebarOpen, setIsEQSidebarOpen] = useState(false);
            const [isSortDropupOpen, setIsSortDropupOpen] = useState(false);
            const [isSearchActive, setIsSearchActive] = useState(false);
            const [searchQuery, setSearchQuery] = useState("");
            const titleRef = useRef(null);
            const artistRef = useRef(null);
            const [eqSettings, setEqSettings] = useState({ low: 0, mid: 0, high: 0 });
            const gapPixels = 30;
            const { isOverflowing: isTitleOverflowing } = useMarquee(songTitle, titleRef, gapPixels);
            const { isOverflowing: isArtistOverflowing } = useMarquee(songArtist, artistRef, gapPixels);
            const filteredPlaylist = playlist.filter((song) => song.name.toLowerCase().includes(searchQuery.toLowerCase()));

            // --- START: Auto-scroll feature additions ---
            const SIDEBAR_ANIMATION_DURATION = 300; // ms, match this with your CSS transition for .playlist-card
            const SCROLL_SETTLE_DELAY = 50; // ms, for scrollTop=0 to paint before smooth scroll
            const [hasScrolledThisSession, setHasScrolledThisSession] = useState(false);

            // Effect to reset scroll flag when sidebar closes
            useEffect(() => {
                if (!isSidebarOpen) {
                    setHasScrolledThisSession(false);
                }
            }, [isSidebarOpen]);

            // Effect for playlist auto-scroll (one-time per open session)
            useEffect(() => {
                const listElement = playlistListRef.current;

                // Conditions to perform scroll:
                // 1. Sidebar must be open.
                // 2. List element must exist.
                // 3. There must be a current song.
                // 4. The one-time scroll for this session must not have happened yet.
                if (!isSidebarOpen || !listElement || currentSongIndex === null || !playlist[currentSongIndex] || hasScrolledThisSession) {
                    return;
                }

                const activeItem = listElement.querySelector('.playlist-item.active');

                if (activeItem) {
                    const offsetTopInList = activeItem.offsetTop;
                    // Calculate scroll position to bring the item towards the center of the visible list
                    const targetScrollTop = offsetTopInList - (listElement.clientHeight / 2) + (activeItem.clientHeight / 2);
                    // Clamp the scroll top to be within valid bounds of the scrollable area
                    const clampedTargetScrollTop = Math.max(0, Math.min(targetScrollTop, listElement.scrollHeight - listElement.clientHeight));

                    // Wait for sidebar opening animation to complete
                    setTimeout(() => {
                        if (playlistListRef.current) { // Check ref again as component might unmount
                            playlistListRef.current.scrollTop = 0; // Scroll to top first

                            // Short delay to allow the scrollTop=0 to paint before smooth scrolling
                            setTimeout(() => {
                                if (playlistListRef.current) { // Check ref again
                                    playlistListRef.current.scrollTo({
                                        top: clampedTargetScrollTop,
                                        behavior: 'smooth'
                                    });
                                    setHasScrolledThisSession(true); // Mark as scrolled for this session
                                }
                            }, SCROLL_SETTLE_DELAY);
                        }
                    }, SIDEBAR_ANIMATION_DURATION);
                } else {
                    // If active item not found (e.g., list is still rendering),
                    // don't set hasScrolledThisSession to true, so it can try again on next render if dependencies change.
                }
            }, [isSidebarOpen, currentSongIndex, playlist, filteredPlaylist, hasScrolledThisSession]); // filteredPlaylist is a dependency because the .active item is rendered based on it.
            // --- END: Auto-scroll feature additions ---


            useEffect(() => {
                const audio = audioRef.current;
                if (!audio) return;
                const handleWaiting = () => setIsBuffering(true);
                const handlePlaying = () => setIsBuffering(false);
                audio.addEventListener('waiting', handleWaiting);
                audio.addEventListener('playing', handlePlaying);
                return () => {
                    audio.removeEventListener('waiting', handleWaiting);
                    audio.removeEventListener('playing', handlePlaying);
                };
            }, []);

            const toggleEQSidebar = () => {
                setIsEQSidebarOpen((prevState) => !prevState);
                setIsSidebarOpen(false);
                if (!isEQSidebarOpen && audioContextRef.current && audioContextRef.current.state === "suspended") {
                    audioContextRef.current.resume().catch((e) => console.error("Error resuming AudioContext:", e));
                }
            };

            const handleEQChange = useCallback((band, value) => {
                setEqSettings((prevSettings) => ({ ...prevSettings, [band]: parseFloat(value) }));
            }, []);

            useEffect(() => {
                const audio = audioRef.current;
                if (!audio) return;
                if (!audioContextRef.current) {
                    audioContextRef.current = new (window.AudioContext || window.webkitAudioContext)();
                }
                const audioContext = audioContextRef.current;
                if (!sourceNodeRef.current || sourceNodeRef.current.mediaElement !== audio) {
                    if (sourceNodeRef.current) sourceNodeRef.current.disconnect();
                    try {
                        sourceNodeRef.current = audioContext.createMediaElementSource(audio);
                    } catch (e) {
                        console.error("Error creating MediaElementSource:", e); return;
                    }
                }
                if (!gainNodeRef.current) {
                    gainNodeRef.current = audioContext.createGain();
                    gainNodeRef.current.gain.value = volume;
                }
                if (!lowShelfFilterRef.current) {
                    lowShelfFilterRef.current = audioContext.createBiquadFilter();
                    lowShelfFilterRef.current.type = "lowshelf";
                    lowShelfFilterRef.current.frequency.value = 250;
                }
                if (!peakingFilterRef.current) {
                    peakingFilterRef.current = audioContext.createBiquadFilter();
                    peakingFilterRef.current.type = "peaking";
                    peakingFilterRef.current.frequency.value = 1500;
                    peakingFilterRef.current.Q.value = 1;
                }
                if (!highShelfFilterRef.current) {
                    highShelfFilterRef.current = audioContext.createBiquadFilter();
                    highShelfFilterRef.current.type = "highshelf";
                    highShelfFilterRef.current.frequency.value = 4000;
                }
                sourceNodeRef.current.disconnect();
                gainNodeRef.current.disconnect();
                lowShelfFilterRef.current.disconnect();
                peakingFilterRef.current.disconnect();
                try {
                    sourceNodeRef.current.connect(gainNodeRef.current);
                    gainNodeRef.current.connect(lowShelfFilterRef.current);
                    lowShelfFilterRef.current.connect(peakingFilterRef.current);
                    peakingFilterRef.current.connect(highShelfFilterRef.current);
                    highShelfFilterRef.current.connect(audioContext.destination);
                } catch (e) { console.error("Error connecting audio nodes:", e); }
            }, []);

            useEffect(() => {
                if (!lowShelfFilterRef.current || !peakingFilterRef.current || !highShelfFilterRef.current) return;
                lowShelfFilterRef.current.gain.value = eqSettings.low;
                peakingFilterRef.current.gain.value = eqSettings.mid;
                highShelfFilterRef.current.gain.value = eqSettings.high;
            }, [eqSettings]);

            useEffect(() => {
                if (gainNodeRef.current) gainNodeRef.current.gain.value = volume;
            }, [volume]);

            const handleSearchClick = () => { setIsSearchActive((prev) => !prev); if (isSearchActive) setSearchQuery(""); };
            const toggleSortDropup = () => setIsSortDropupOpen((prev) => !prev);

            const sortPlayListBy = (criteria) => {
                setPlaylist((prevPlaylist) => {
                    const currentSongFile = currentSongIndex !== null ? prevPlaylist[currentSongIndex] : null;
                    const newPlaylist = [...prevPlaylist];
                    newPlaylist.sort((a, b) => {
                        let valA, valB;
                        if (criteria === "title") { valA = (a.name || "").toLowerCase(); valB = (b.name || "").toLowerCase(); }
                        else if (criteria === "artist") { valA = (a.metadata?.artist || a.name || "").toLowerCase(); valB = (b.metadata?.artist || b.name || "").toLowerCase(); }
                        else if (criteria === "dateAdded") { valA = a.lastModified; valB = b.lastModified; }
                        if (valA < valB) return -1; if (valA > valB) return 1; return 0;
                    });
                    if (currentSongFile) { // Re-find the current song's index after sorting
                        const newIdx = newPlaylist.findIndex(song => song === currentSongFile);
                        if (newIdx !== -1) setCurrentSongIndex(newIdx);
                        else setCurrentSongIndex(null); // Should not happen if song objects are stable
                    }
                    return newPlaylist;
                });
                setIsSortDropupOpen(false);
            };

            useEffect(() => {
                const handleClickOutside = (event) => {
                    if (isSortDropupOpen && dropupMenuRef.current && !dropupMenuRef.current.contains(event.target) && sortButtonRef.current && !sortButtonRef.current.contains(event.target)) {
                        setIsSortDropupOpen(false);
                    }
                };
                const positionDropupMenu = () => {
                    if (isSortDropupOpen && sortButtonRef.current && dropupMenuRef.current) {
                        const buttonRect = sortButtonRef.current.getBoundingClientRect();
                        const menuElement = dropupMenuRef.current;
                        menuElement.style.top = `${buttonRect.top - menuElement.offsetHeight - 10}px`;
                        menuElement.style.left = `${buttonRect.left}px`;
                        menuElement.style.minWidth = `${buttonRect.width}px`;
                    }
                };
                if (isSortDropupOpen) {
                    document.addEventListener("mousedown", handleClickOutside);
                    window.addEventListener("resize", positionDropupMenu);
                    window.addEventListener("scroll", positionDropupMenu, true); // Listen on all scroll events
                    setTimeout(positionDropupMenu, 0);
                }
                return () => {
                    document.removeEventListener("mousedown", handleClickOutside);
                    window.removeEventListener("resize", positionDropupMenu);
                    window.removeEventListener("scroll", positionDropupMenu, true);
                };
            }, [isSortDropupOpen]);

            const calculateSliderPositions = useCallback(() => {
                if (!sliderBoxRef.current || duration === 0) {
                    return { thumbLeft: 0, colorWidth: 0 };
                }
                const htmlFontSize = parseFloat(getComputedStyle(document.documentElement).fontSize);
                const thumbWidthPx = 2 * htmlFontSize;
                const halfThumbWidthPx = thumbWidthPx / 2;
                const trackWidthPx = sliderBoxRef.current.clientWidth;
                let rawProgressRatio = currentTime / duration;
                rawProgressRatio = Math.max(0, Math.min(1, rawProgressRatio));
                const effectiveTrackWidthForThumbCenter = trackWidthPx - thumbWidthPx;
                let thumbCenterPx = rawProgressRatio * effectiveTrackWidthForThumbCenter;
                thumbCenterPx += halfThumbWidthPx;
                const colorFillPx = thumbCenterPx;
                const thumbLeftPercentage = (thumbCenterPx / trackWidthPx) * 100;
                const colorWidthPercentage = (colorFillPx / trackWidthPx) * 100;
                return {
                    thumbLeft: Math.max(0, Math.min(100, thumbLeftPercentage)),
                    colorWidth: Math.max(0, Math.min(100, colorWidthPercentage))
                };
            }, [currentTime, duration]);

            const { thumbLeft, colorWidth } = calculateSliderPositions();
            const handleSearchChange = (e) => setSearchQuery(e.target.value);

            const shuffleArray = (array) => {
                let currentIndex = array.length, randomIndex;
                while (currentIndex !== 0) {
                    randomIndex = Math.floor(Math.random() * currentIndex);
                    currentIndex--;
                    [array[currentIndex], array[randomIndex]] = [array[randomIndex], array[currentIndex]];
                }
                return array;
            };

            const toggleRepeat = () => {
                setIsRepeating((prevRepeating) => {
                    const newRepeatingState = !prevRepeating;
                    if (newRepeatingState) setIsShuffling(false);
                    if (audioRef.current) audioRef.current.loop = newRepeatingState;
                    return newRepeatingState;
                });
            };

            const toggleShuffle = () => {
                setIsShuffling((prevShuffling) => {
                    const newShufflingState = !prevShuffling;
                    if (newShufflingState) {
                        setIsRepeating(false);
                        if (audioRef.current) audioRef.current.loop = false;
                        setPlaylist((oldPlaylist) => {
                            const currentSong = currentSongIndex !== null ? oldPlaylist[currentSongIndex] : null;
                            const shuffled = shuffleArray([...oldPlaylist.filter(song => song !== currentSong)]);
                            const newPlaylist = currentSong ? [currentSong, ...shuffled] : shuffled;
                            if (currentSong) {
                                const newIdx = newPlaylist.findIndex(s => s === currentSong);
                                if (newIdx !== -1) setCurrentSongIndex(newIdx); else setCurrentSongIndex(0); // Fallback
                            } else if (newPlaylist.length > 0) {
                                setCurrentSongIndex(0);
                            }
                            return newPlaylist;
                        });
                    }
                    return newShufflingState;
                });
            };

            const playNextSong = useCallback(async () => {
                if (playlist.length === 0) return;
                const audio = audioRef.current;
                if (!audio) return;

                if (audioContextRef.current && audioContextRef.current.state === "suspended") {
                    try { await audioContextRef.current.resume(); }
                    catch (e) { console.error("Error resuming AudioContext in playNextSong:", e); }
                }

                let nextIndex;
                if (isShuffling) {
                    if (playlist.length <= 1) {
                        nextIndex = 0; // Loop the single song if shuffling and only one song
                        if (playlist.length === 0) nextIndex = null;
                    } else {
                        do { nextIndex = Math.floor(Math.random() * playlist.length); }
                        while (playlist.length > 1 && nextIndex === currentSongIndex);
                    }
                } else {
                    if (currentSongIndex === null || currentSongIndex === playlist.length - 1) {
                        nextIndex = 0;
                        if (!isRepeating && currentSongIndex === playlist.length - 1) {
                            setIsPlaying(false);
                            // Optionally reset to first song paused: setCurrentSongIndex(0); 
                            return;
                        }
                    } else {
                        nextIndex = currentSongIndex + 1;
                    }
                }

                if (nextIndex !== null && playlist[nextIndex]) {
                    setCurrentSongIndex(nextIndex);
                    setIsPlaying(true);
                } else if (playlist.length > 0) { // Fallback for safety
                    setCurrentSongIndex(0);
                    setIsPlaying(true);
                } else {
                    setIsPlaying(false);
                }
            }, [playlist, currentSongIndex, isShuffling, isRepeating, audioRef, audioContextRef]);


            const handleError = useCallback((event) => {
                const audioElement = event.target;
                console.error("Audio playback error event object:", event);
                if (audioElement.error) {
                    console.error("MediaError code:", audioElement.error.code, "Message:", audioElement.error.message);
                } else {
                    console.error("No MediaError object available on the audio element.");
                }
                setIsPlaying(false);
                // Optionally, try to play next song after a delay
                // setTimeout(() => playNextSong(), 1000);
            }, [setIsPlaying]);

            useEffect(() => {
                const audio = audioRef.current;
                if (!audio) return;
                const handleTimeUpdate = () => setCurrentTime(audio.currentTime);
                const handleLoadedMetadata = () => setDuration(audio.duration);

                const handleAudioEnded = async () => {
                    if (!isRepeating) {
                        await playNextSong();
                    } else {
                        // If repeating, audio.loop=true should handle it.
                        // Ensure UI state is consistent if browser doesn't fire 'play' event on loop.
                        if (audio.loop) {
                            audio.currentTime = 0; // Reset time
                            try {
                                await audio.play(); // Ensure it plays
                                setIsPlaying(true); // Sync state
                            } catch (e) {
                                console.error("Error re-playing looped audio:", e);
                                setIsPlaying(false);
                            }
                        } else { // Fallback if loop attribute was somehow lost
                            await playNextSong();
                        }
                    }
                };

                audio.addEventListener('timeupdate', handleTimeUpdate);
                audio.addEventListener('loadedmetadata', handleLoadedMetadata);
                audio.addEventListener('ended', handleAudioEnded);
                audio.addEventListener('error', handleError);
                return () => {
                    audio.removeEventListener('timeupdate', handleTimeUpdate);
                    audio.removeEventListener('loadedmetadata', handleLoadedMetadata);
                    audio.removeEventListener('ended', handleAudioEnded);
                    audio.removeEventListener('error', handleError);
                };
            }, [playNextSong, isRepeating, handleError]);


            useEffect(() => {
                const audio = audioRef.current;
                if (!audio) return;

                if (currentObjectUrl.current) {
                    URL.revokeObjectURL(currentObjectUrl.current);
                    currentObjectUrl.current = null;
                }

                if (currentSongIndex !== null && playlist[currentSongIndex]) {
                    const song = playlist[currentSongIndex];
                    const newObjectUrl = URL.createObjectURL(song);
                    currentObjectUrl.current = newObjectUrl;

                    audio.src = newObjectUrl;
                    audio.loop = isRepeating;

                    jsmediatags.read(song, {
                        onSuccess: function (tag) {
                            const title = tag.tags.title || song.name.split('.').slice(0, -1).join('.') || song.name;
                            const artist = tag.tags.artist || '';
                            setSongTitle(title); setSongArtist(artist);
                            if (tag.tags.picture) {
                                const base64String = arrayBufferToBase64(tag.tags.picture.data);
                                setAlbumArtUrl(`data:${tag.tags.picture.format};base64,${base64String}`);
                            } else { setAlbumArtUrl("https://placehold.co/200x200/bec8e4/9baacf?text=No+Art"); }
                        },
                        onError: function (error) {
                            console.error("Error reading media tags:", error);
                            setSongTitle(song.name.split('.').slice(0, -1).join('.') || song.name);
                            setSongArtist(""); setAlbumArtUrl("https://placehold.co/200x200/bec8e4/9baacf?text=No+Art");
                        }
                    });

                    const attemptPlayOnLoad = async () => {
                        if (audioContextRef.current && audioContextRef.current.state === "suspended") {
                            try { await audioContextRef.current.resume(); }
                            catch (e) { console.error("attemptPlayOnLoad: Error resuming AudioContext:", e); }
                        }
                        // Use isPlayingRef.current to check the *intent* to play
                        if (isPlayingRef.current && audio.src && audio.readyState >= HTMLMediaElement.HAVE_ENOUGH_DATA) {
                            try {
                                await audio.play();
                            } catch (error) {
                                console.error("attemptPlayOnLoad: Error during audio.play():", error.name, error.message);
                                if (error.name === 'NotAllowedError') { setIsPlaying(false); }
                            }
                        }
                    };

                    const handleCanPlayThrough = () => {
                        setDuration(audio.duration); // Also set duration here
                        if (isPlayingRef.current) { // Check intent to play
                            attemptPlayOnLoad();
                        }
                    };

                    audio.load(); // Important to load the new source
                    audio.addEventListener('canplaythrough', handleCanPlayThrough, { once: true });

                    return () => {
                        audio.removeEventListener('canplaythrough', handleCanPlayThrough);
                    };

                } else {
                    if (audio.src) audio.src = "";
                    setSongTitle("Tidak ada lagu yang sedang diputar");
                    setSongArtist("");
                    setAlbumArtUrl("https://placehold.co/200x200/bec8e4/9baacf?text=No+Art");
                    setCurrentTime(0);
                    setDuration(0);
                    // setIsPlaying(false); // Let useAudioStateSync handle this if audio pauses
                }
            }, [currentSongIndex, playlist, isRepeating, audioRef, audioContextRef]);


            const handleFileChange = (event) => {
                const files = Array.from(event.target.files);
                const audioFiles = files.filter(file => file.type.startsWith("audio/") || /\.(mp3|wav|ogg|flac|m4a)$/i.test(file.name));
                if (audioFiles.length > 0) {
                    const newPlaylistFiles = [...audioFiles];
                    setPlaylist(newPlaylistFiles);
                    if (newPlaylistFiles.length > 0) {
                        setCurrentSongIndex(0);
                        setIsPlaying(false); // Don't autoplay new folder
                    } else {
                        setCurrentSongIndex(null);
                        setIsPlaying(false);
                    }
                    if (isShuffling) {
                        setPlaylist(shuffleArray([...newPlaylistFiles]));
                    }
                }
                if (fileInputRef.current) fileInputRef.current.value = "";
            };

            const openFolder = () => fileInputRef.current.click();

            const openSingleFile = () => {
                const input = document.createElement("input");
                input.type = "file";
                input.accept = "audio/*,.mp3,.wav,.ogg,.flac,.m4a";
                input.onchange = (event) => {
                    const file = event.target.files[0];
                    if (file) {
                        setPlaylist((prevPlaylist) => {
                            const updatedPlaylist = [...prevPlaylist, file];
                            if (currentSongIndex === null && updatedPlaylist.length === 1) {
                                setCurrentSongIndex(0);
                                setIsPlaying(false);
                            } else if (isShuffling) {
                                const currentSongFile = currentSongIndex !== null ? prevPlaylist[currentSongIndex] : null;
                                let filesToShuffle = [...prevPlaylist, file];
                                let newShuffledPlaylist;
                                if (currentSongFile) {
                                    filesToShuffle = filesToShuffle.filter(s => s !== currentSongFile);
                                    newShuffledPlaylist = [currentSongFile, ...shuffleArray(filesToShuffle)];
                                    const newIdx = newShuffledPlaylist.findIndex(s => s === currentSongFile);
                                    if (newIdx !== -1) setCurrentSongIndex(newIdx); else setCurrentSongIndex(0);
                                } else {
                                    newShuffledPlaylist = shuffleArray(filesToShuffle);
                                    if (newShuffledPlaylist.length > 0) setCurrentSongIndex(0); else setCurrentSongIndex(null);
                                    setIsPlaying(false);
                                }
                                return newShuffledPlaylist;
                            }
                            return updatedPlaylist;
                        });
                    }
                };
                input.click();
            };

            const togglePlayPause = useCallback(async () => {
                if (playlist.length === 0 || currentSongIndex === null) {
                    // If no song is selected but playlist has items, perhaps select the first one?
                    // For now, if currentSongIndex is null, and play is pressed, it does nothing.
                    // User should click a song in the playlist first if currentSongIndex is null.
                    setIsPlaying(false);
                    return;
                }

                const audio = audioRef.current;
                if (!audio) {
                    setIsPlaying(false);
                    return;
                }

                try {
                    if (audioContextRef.current && audioContextRef.current.state === "suspended") {
                        await audioContextRef.current.resume();
                    }

                    if (!isPlayingRef.current) { // If intent is to PLAY (currently paused/stopped)
                        if (audio.src && audio.readyState >= HTMLMediaElement.HAVE_METADATA) {
                            // Song is loaded (or at least metadata is available), just paused.
                            // Force a re-trigger of the song loading effect to refresh metadata,
                            // especially if replaying the same song that just ended.
                            setCurrentSongIndex(idx => idx); // <--- KEY CHANGE FOR REPLAY METADATA
                            await audio.play();
                            // setIsPlaying(true) will be handled by useAudioStateSync via 'play' event
                        } else if (playlist[currentSongIndex]) { // No src, or src but not ready. Song needs full load/reload.
                            // This also covers the case where src might have been cleared.
                            setIsPlaying(true); // Set intent to play *before* triggering effect.
                            // So isPlayingRef.current will be true when the song loading effect runs.
                            setCurrentSongIndex(idx => idx); // Trigger song loading effect (which sets src and plays)
                        } else {
                            // Should not happen if currentSongIndex is valid and playlist has items.
                            setIsPlaying(false);
                        }
                    } else { // If intent is to PAUSE
                        if (!audio.paused) {
                            audio.pause();
                            // setIsPlaying(false) will be handled by useAudioStateSync via 'pause' event
                        }
                    }
                } catch (error) {
                    console.error("Error in togglePlayPause (play/pause attempt):", error);
                    setIsPlaying(false); // Ensure UI reflects paused state on error
                }
            }, [playlist, currentSongIndex, audioRef, audioContextRef /* setIsPlaying not needed as dep here */]);

            const playSong = useCallback(async (indexInFiltered) => {
                const actualIndex = playlist.indexOf(filteredPlaylist[indexInFiltered]);
                if (actualIndex === -1) return;
                const audio = audioRef.current;
                if (!audio) return;

                try {
                    if (audioContextRef.current && audioContextRef.current.state === "suspended") {
                        await audioContextRef.current.resume();
                    }
                    if (actualIndex !== currentSongIndex) {
                        setCurrentSongIndex(actualIndex);
                        setIsPlaying(true);
                    } else {
                        await togglePlayPause();
                    }
                } catch (error) { setIsPlaying(false); }
            }, [playlist, filteredPlaylist, currentSongIndex, togglePlayPause]);

            const playPreviousSong = async () => {
                if (playlist.length === 0) return;
                if (audioContextRef.current && audioContextRef.current.state === "suspended") {
                    try { await audioContextRef.current.resume(); }
                    catch (e) { console.error("Error resuming context in playPreviousSong", e); }
                }
                let prevIndex;
                if (isShuffling) {
                    if (playlist.length <= 1) prevIndex = 0;
                    else {
                        do { prevIndex = Math.floor(Math.random() * playlist.length); }
                        while (playlist.length > 1 && prevIndex === currentSongIndex);
                    }
                } else {
                    prevIndex = (currentSongIndex !== null ? currentSongIndex - 1 + playlist.length : playlist.length - 1) % playlist.length;
                }
                setCurrentSongIndex(prevIndex);
                setIsPlaying(true);
            };

            const handleProgressBarChange = (e) => {
                const audio = audioRef.current;
                if (!audio || isNaN(audio.duration) || audio.duration === 0) return;
                const newTime = parseFloat(e.target.value);
                audio.currentTime = newTime;
                // setCurrentTime(newTime); // Updated by 'timeupdate' event
            };

            const handleVolumeChange = (e) => {
                const newVolume = parseFloat(e.target.value);
                setVolume(newVolume);
            };

            const formatTime = (seconds) => {
                if (isNaN(seconds) || seconds < 0) return "0:00";
                const minutes = Math.floor(seconds / 60);
                const remainingSeconds = Math.floor(seconds % 60);
                return `${minutes}:${remainingSeconds < 10 ? "0" : ""}${remainingSeconds}`;
            };

            const toggleSidebar = () => { setIsSidebarOpen((prevState) => !prevState); setIsEQSidebarOpen(false); };
            const handleCloseBothSidebars = () => { setIsSidebarOpen(false); setIsEQSidebarOpen(false); };

            const handleDeleteSong = (indexToDeleteInOriginal, event) => {
                event.stopPropagation();
                setPlaylist((prevPlaylist) => {
                    const songToDelete = prevPlaylist[indexToDeleteInOriginal];
                    const newPlaylist = prevPlaylist.filter((_, idx) => idx !== indexToDeleteInOriginal);

                    if (newPlaylist.length === 0) {
                        setCurrentSongIndex(null);
                        setIsPlaying(false);
                        if (audioRef.current) { audioRef.current.pause(); audioRef.current.src = ""; }
                    } else if (currentSongIndex === indexToDeleteInOriginal) {
                        // If the deleted song was playing or selected
                        // Play the next available song (or first if deleted was last)
                        // The isPlaying state will be handled by the song loading effect
                        const newIndexToPlay = indexToDeleteInOriginal % newPlaylist.length;
                        setCurrentSongIndex(newIndexToPlay);
                        // If it was playing, the new song should start playing due to isPlayingRef.current
                    } else if (currentSongIndex !== null && currentSongIndex > indexToDeleteInOriginal) {
                        setCurrentSongIndex(currentSongIndex - 1);
                    }
                    return newPlaylist;
                });
            };

            const clearPlayList = () => {
                setPlaylist([]);
                setCurrentSongIndex(null);
                setIsPlaying(false);
                setSearchQuery("");
                setIsRepeating(false);
                setIsShuffling(false);
                if (audioRef.current) {
                    audioRef.current.pause();
                    audioRef.current.src = "";
                    audioRef.current.loop = false;
                }
                if (fileInputRef.current) fileInputRef.current.value = "";
                setEqSettings({ low: 0, mid: 0, high: 0 });
                // Reset song info display
                setSongTitle("Tidak ada lagu yang sedang diputar");
                setSongArtist("");
                setAlbumArtUrl("https://placehold.co/200x200/bec8e4/9baacf?text=No+Art");
                setCurrentTime(0);
                setDuration(0);
            };

            return (
                <div className="container">
                    <div
                        className={`playlist-card ${isSidebarOpen || isEQSidebarOpen ? "open" : "collapsed"
                            }`}
                    >
                        <div className="playlist-header">
                            {isSidebarOpen && <h3>Playlist</h3>}
                            {isEQSidebarOpen && <h3>Equalizer</h3>}
                            <div className="header-buttons-group">
                                {isSidebarOpen && (
                                    <button
                                        className="search-toggle-btn"
                                        onClick={handleSearchClick}
                                        aria-label="Search Playlist"
                                    >
                                        <i className="fas fa-search"></i>
                                    </button>
                                )}
                                <button
                                    className="sidebar-toggle-btn"
                                    onClick={
                                        isSidebarOpen || isEQSidebarOpen
                                            ? handleCloseBothSidebars
                                            : toggleSidebar
                                    }
                                    aria-label={
                                        isSidebarOpen || isEQSidebarOpen
                                            ? "Close Sidebars"
                                            : "Open Playlist"
                                    }
                                >
                                    <i
                                        className={`fas ${isSidebarOpen || isEQSidebarOpen
                                            ? "fa-times"
                                            : "fa-bars"
                                            }`}
                                    ></i>
                                </button>
                            </div>
                        </div>

                        {/* Wrapper for playlist content to manage flex layout and height */}
                        {isSidebarOpen && !isEQSidebarOpen && (
                            <div className="playlist-content-wrapper" style={{ display: 'flex', flexDirection: 'column', flexGrow: 1, overflow: 'hidden', height: 'calc(100% - 3.5rem)' /* Adjust if header height changes */ }}>
                                {isSearchActive && (
                                    <div className="search-input-container" style={{ flexShrink: 0, padding: '0.5rem' }}>
                                        <input
                                            type="text"
                                            placeholder="Cari lagu..."
                                            value={searchQuery}
                                            onChange={handleSearchChange}
                                            className="search-input"
                                        />
                                    </div>
                                )}
                                <ul className="playlist-list" ref={playlistListRef} style={{ flexGrow: 1, overflowY: 'auto', padding: '0 0.5rem' }}>
                                    {filteredPlaylist.length === 0 && searchQuery !== "" ? (
                                        <li className="playlist-empty">No matching songs found.</li>
                                    ) : playlist.length === 0 ? (
                                        <li className="playlist-empty">Belum ada lagu yang ditambahkan.</li>
                                    ) : (
                                        filteredPlaylist.map((song, indexInFiltered) => {
                                            const originalIndex = playlist.indexOf(song); // Get original index for key and active check
                                            return (
                                                <li
                                                    key={song.name + originalIndex + (song.lastModified || indexInFiltered)} // Add lastModified for better key
                                                    className={`playlist-item ${currentSongIndex === originalIndex ? "active" : ""}`}
                                                >
                                                    <div
                                                        className="playlist-item-inner"
                                                        onClick={() => playSong(indexInFiltered)} // Pass index from filtered list
                                                    >
                                                        <span className="playlist-song-name">
                                                            {song.name.split(".").slice(0, -1).join(".") || song.name}
                                                        </span>
                                                        <button
                                                            className="btn btn__delete"
                                                            onClick={(e) => handleDeleteSong(originalIndex, e)} // Pass original index
                                                            aria-label={`Delete ${song.name}`}
                                                        >
                                                            <i className="fas fa-trash-alt"></i>
                                                        </button>
                                                    </div>
                                                </li>
                                            )
                                        })
                                    )}
                                </ul>
                                <div className="button-container-flex" style={{ marginTop: "auto", paddingTop: "1rem", paddingBottom: '0.5rem', flexShrink: 0, paddingLeft: '0.5rem', paddingRight: '0.5rem' }}>
                                    <button className="btn btn-pl btn__secondary" onClick={openFolder} title="Buka Folder">
                                        <i className="fas fa-folder"></i>
                                    </button>
                                    <button className="btn btn-pl btn__secondary" onClick={openSingleFile} title="Tambahkan File ke Playlist">
                                        <i className="fas fa-file-audio"></i>
                                    </button>
                                    <button className="btn btn-pl btn__secondary" onClick={clearPlayList} title="Bersihkan Playlist">
                                        <i className="fas fa-trash"></i>
                                    </button>
                                    <div className="dropup-container-absolute">
                                        <div className="dropup">
                                            <button className="btn btn-pl btn__secondary dropup-toggle" onClick={toggleSortDropup} title="Urutkan Playlist berdasarkan..." ref={sortButtonRef}>
                                                <i className="fa-solid fa-sort"></i>
                                            </button>
                                            {isSortDropupOpen && (
                                                <div className="dropup-menu" ref={dropupMenuRef} style={{ position: "fixed", zIndex: 1000 }}>
                                                    <button className="dropup-item" onClick={() => sortPlayListBy("title")}>Judul</button>
                                                    <button className="dropup-item" onClick={() => sortPlayListBy("artist")}>Artist</button>
                                                    <button className="dropup-item" onClick={() => sortPlayListBy("dateAdded")}>Tanggal</button>
                                                </div>
                                            )}
                                        </div>
                                    </div>
                                    <button className="btn btn-pl btn__secondary" title="Pengaturan" onClick={() => console.log("Settings clicked")}>
                                        <i className="fa-solid fa-gear"></i>
                                    </button>
                                </div>
                            </div>
                        )}

                        {!isSidebarOpen && !isEQSidebarOpen && (
                            <>
                                <button
                                    className={`sidebar-toggle-btn mt-3 ${isEQSidebarOpen ? "eq-button-hidden" : ""}`}
                                    aria-label="Open Equalizer"
                                    onClick={toggleEQSidebar}
                                    style={{ alignSelf: 'center' }} // Keep EQ button centered
                                >
                                    <i className="fas fa-sliders" aria-hidden="true"></i>
                                </button>
                                <div className="playlist-card-logo mb-3 font-weight-bold" style={{ textAlign: 'center', marginTop: 'auto' }}>
                                    Kyrop<i className="fas fa-compact-disc"></i>d
                                </div>
                            </>
                        )}


                        {isEQSidebarOpen && !isSidebarOpen && (
                            <div className="eq-controls">
                                <div className="eq-band">
                                    <label>Bass</label>
                                    <input type="range" min="-12" max="12" step="0.5" value={eqSettings.low} onChange={(e) => handleEQChange("low", e.target.value)} className="eq-slider" />
                                    <span>{eqSettings.low}dB</span>
                                </div>
                                <div className="eq-band">
                                    <label>Mid</label>
                                    <input type="range" min="-12" max="12" step="0.5" value={eqSettings.mid} onChange={(e) => handleEQChange("mid", e.target.value)} className="eq-slider" />
                                    <span>{eqSettings.mid}dB</span>
                                </div>
                                <div className="eq-band">
                                    <label>Treble</label>
                                    <input type="range" min="-12" max="12" step="0.5" value={eqSettings.high} onChange={(e) => handleEQChange("high", e.target.value)} className="eq-slider" />
                                    <span>{eqSettings.high}dB</span>
                                </div>
                                <button className="btn btn-pl btn__secondary" onClick={() => setEqSettings({ low: 0, mid: 0, high: 0 })} style={{ marginTop: "1rem" }}>
                                    Reset EQ
                                </button>
                            </div>
                        )}
                        <input type="file" webkitdirectory="" directory="" multiple="" ref={fileInputRef} onChange={handleFileChange} style={{ display: "none" }} accept="audio/*,.mp3,.wav,.ogg,.flac,.m4a" />
                    </div>

                    {/* Main Player Card */}
                    <div className="player-card">
                        <div className="album-art-wrapper">
                            <img src={albumArtUrl} alt="Album Art" className="album-art" onError={(e) => { e.target.onerror = null; e.target.src = "https://placehold.co/200x200/bec8e4/9baacf?text=No+Art"; }} />
                        </div>
                        <div className="song-info mt-2">
                            <h2 className={`song-title ${isTitleOverflowing ? "is-scrolling" : ""}`} ref={titleRef} title={songTitle}>
                                <span>{songTitle}{isTitleOverflowing && (<><span style={{ width: `${gapPixels}px`, display: "inline-block", }}></span>{songTitle}</>)}</span>
                            </h2>
                            <p className={`song-artist ${isArtistOverflowing ? "is-scrolling-artist" : ""}`} ref={artistRef} title={songArtist}>
                                <span>{songArtist}{isArtistOverflowing && (<><span style={{ width: `${gapPixels}px`, display: "inline-block", }}></span>{songArtist}</>)}</span>
                            </p>
                        </div>

                        <div className="controls-wrapper">
                            <div className="slider">
                                <div className="slider__box" ref={sliderBoxRef}>
                                    <input type="range" min="0" max={duration || 0} value={currentTime} onChange={handleProgressBarChange} className="progress-slider" disabled={playlist.length === 0 || duration === 0} />
                                    <span className="slider__btn" style={{ left: `calc(${thumbLeft}% - 1rem)` }} ></span> {/* Adjusted for 2rem thumb */}
                                    <span className="slider__color" style={{ width: `${colorWidth}%` }} ></span> {/* Color width matches thumb center */}
                                </div>
                                <div className="time-display">
                                    <span>{formatTime(currentTime)}</span>
                                    <span>{formatTime(duration)}</span>
                                </div>
                            </div>

                            <div className="player-buttons">
                                <button className={`icon__repeat ${isRepeating ? "active" : ""}`} onClick={toggleRepeat} aria-label="Repeat Song" disabled={playlist.length === 0}>
                                    <i className="fas fa-redo"></i>
                                </button>
                                <button className="icon__prev" onClick={playPreviousSong} aria-label="Previous Song" disabled={playlist.length === 0}>
                                    <i className="fas fa-step-backward"></i>
                                </button>
                                <div className="circle">
                                    <button className={`circle__btn ${isPlaying ? "shadow" : ""}`} onClick={togglePlayPause} aria-label={isPlaying ? "Pause" : "Play"} disabled={playlist.length === 0}>
                                        <i className="fas fa-play"></i>
                                        <i className="fas fa-pause"></i>
                                    </button>
                                    <div className={`circle__back-1 ${isPlaying && playlist.length > 0 && !isBuffering ? "" : "paused"}`}></div>
                                    <div className={`circle__back-2 ${isPlaying && playlist.length > 0 && !isBuffering ? "" : "paused"}`}></div>
                                </div>
                                <button className="icon__next" onClick={playNextSong} aria-label="Next Song" disabled={playlist.length === 0}>
                                    <i className="fas fa-step-forward"></i>
                                </button>
                                <button className={`icon__shuffle ${isShuffling ? "active" : ""}`} onClick={toggleShuffle} aria-label="Shuffle Playlist" disabled={playlist.length === 0}>
                                    <i className="fas fa-random"></i>
                                </button>
                            </div>

                            <div className="volume-control">
                                <i className="fas fa-volume-down"></i>
                                <input type="range" min="0" max="1" step="0.01" value={volume} onChange={handleVolumeChange} className="volume-slider" aria-label="Volume Slider" disabled={playlist.length === 0} />
                                <i className="fas fa-volume-up"></i>
                            </div>
                        </div>
                    </div>
                    <audio ref={audioRef} preload="metadata"></audio>
                    {isBuffering && <div className="buffering-indicator" style={{ position: 'fixed', bottom: '10px', left: '50%', transform: 'translateX(-50%)', backgroundColor: 'rgba(0,0,0,0.7)', color: 'white', padding: '5px 10px', borderRadius: '5px', zIndex: 2000 }}>Buffering...</div>}
                </div>
            );
        }

        ReactDOM.render(<App />, document.getElementById("root"));
    </script>
</body>

</html>